MongoDB:
	It is not an RDBMS!
	It is a NoSQL database.
	"Not Only SQL" or "Not SQL".
	You cannot run SQL queries like:
		SELECT * FROM tablename....
		INSERT INTO tablenbame(...) VALUES (...)
	In RDBMS, we have tables, rows.
	In NoSQL, we have collections, documents.
	The format in which the docs are stored in the DB is JSON format.
	
	In RDBMS, we may have:
		PRODUCTS table: ProductID, ProductName, CategoryID
		CATEGORIES table: CategoryID, CategoryName
		
	In NoSQL, we will have:
		ProductsCategory collection: productId, productname, categoryid, categoryname
		
	NoSQL is a non-relational DB. There is no PK-FK relations.
	Avoid joins in a NoSQL db.
	The performance of fetching data is much faster.
	NoSQL dbs are catered towards processing and handling of large datasets.
	NoSQL are easier to scale, and are meant for distributed processing.
	NoSQL concept was introduced in the late 90s, around 1998.
	SQL: there is predefined schema. NoSQL: there is no predefined schema. NoSQL is unstructured.
	SQL: MS SQL Server, Oracle, Postgres etc. NoSQL: MongoDB, Hbase, Cassandra, CouchBase.
	Most NoSQL are opensource.
	SQL: used for solving the ACID problems. NoSQL: solving the problem of availability of data.
	SQL: ACID. NoSQL: BASE - Basically Available, Soft state, Eventually consistent.
	BASE:
		Basically Available: The system is guranteed to be available in the event of a failure. This is due to the distributed nature of NoSQL DBs.
		Soft state: The state of the data could change without  application interactions due to eventual consistency.
		Eventual consitency: The system will be eventually consistent after data is given to the system (DB). The data will be replicated to different nodes and will eventually reach a consistent state.
		
MongoDB:
	Open source DB.
	Written in C++.
	Fully scalable.
	It does not support SQL syntax (because it is a NoSQL DB).
	It supports a rich, ad-hoc query language of its own.
	It stores data as documents in collections.
	It is a "document oriented database".
	
	
To start MongoDB, open a command prompt / terminal and start the server:
•	Create the database directory. Open a command prompt and run:
mkdir c:\data\db
•	Start MongoDB from the command line with:
"C:\Program Files\MongoDB\Server\4.4\bin\mongod.exe" --dbpath="c:\data\db"
•	Open another command prompt and connect to MongoDB with:
"C:\Program Files\MongoDB\Server\4.4\bin\mongo.exe"

Commands:
show dbs
db.test.find()			# SELECT * FROM test
db.dropDatabase()		# delete current database.
use <dbname>
show tables				# display table (collection) names.
db.getCollectionNames()	# list of collections
db.createCollection("coll_name")	# create a new collection named "coll_name")
db.collectioname.drop()		# drop/delete a collection.
Insert docs in a collection:
db.collectioname.insert( data )	# The data has to be in JSON format.
For e.g.;
db.boyDiapers.insert( [{size: 1, color: 'blue', brand: 'toddler tykes' }] )
db.girlDiapers.insert( [{size: 1, color: 'white', brand: 'little angel' }, {size: 1, color: 'pink', brand: 'little angel' }, {size: 2, color: 'white', brand: 'little angel' }] )

db.girlDiapers.insert( [{size: 9, color: 'white', brand: 'toddler tykes' }, {size: 9, color: 'pink', brand: 'toddler tykes' }, {size: 10, color: 'white', brand: 'toddler tykes' }, {size: 10, color: 'pink', brand: 'toddler tykes' }] )

all documents in MongoDB have a built-in "key" attribute called "_id", the value of which is auto-generated by MongoDB.

db.girlDiapers.find()	# display docs in the collection.
	By default, find() displays the first 20 docs.
	
db.girlDiapers.find().pretty()		# display the JSON docs in a "pretty" format.

SELECT * FROM girDiapers
WHERE Size = 2

db.girlDiapers.find({"size": 2})

Things to remember about MongoDB:
Max size of a doc is 16MB.
BSON: Binary JSON. Max size 16MB.
Max no. of indexes on a collection is 64.
It is a document-oriented DB.
Stores data in collections and not tables.
Data is in documents, not rows.
It uses dynamic schema.
MongoDB client drivers exist for many programming languages like Python, Scala, Java etc.
It does not support SQL. But it has its own non-SQL, ad-hoc query syntax.
Usually used in content management system, social media sites/apps, analytics, ecommerce, logging.
It does not support transactions. No ACID. But there is BASE.
It also supports caching of data. It keeps all most recently used data in RAM.


INSERT documents:
db.girlDiapers.insert()
db.girlDiapers.insertOne( {} )
db.girlDiapers.insertMany([{}])
db.girlDiapers.insertMany([{}, {}, {}])

db.girlDiapers.find()
db.girlDiapers.find({})
db.girlDiapers.find({ cond1, cond2 })
db.girlDiapers.find({ "size": 1, "color": "white" })

Match attribute in a complex dpocument (json within json):
db.inventory.find({ "size.uom": "cm" })
db.inventory.find({ "size.h": { $gt : 10 } })			> 10
db.inventory.find({ "size.h": { $gte : 10 } })			>= 10
db.inventory.find({ "size.h": { $lt : 10 } })			< 10
db.inventory.find({ "size.h": { $lte : 10 } })			<= 10
db.inventory.find({ "size.h": { $eq : 10 } })			== 10
db.inventory.find({ "size.h": { $ne : 10 } })			!= 10

SELECT Id, Name FROM table
db.inventory.find({ "size.uom": "cm" }, {"item": 1})		show only item attr.
db.inventory.find({ "size.uom": "cm" }, {"item": 0})		show all attrs except item.
db.inventory.find({ "size.uom": "cm" }, {"qty": 0, "size": 0})		show all attrs except qty and size.

AND:
db.girlDiapers.find({ "size": 1, "color": "white" })
db.girlDiapers.find( {$and: [{ "size": 1}, {"color": "white" }] })
db.girlDiapers.find( {$or: [{ "size": 1}, {"color": "white" }] })

SELECT Item FROM inventory
db.inventory.find( {}, { "item": 1 } )

Search based on the built-in auto-generated id:
db.inventory.find( {"_id": "60eaba305e66d126ddb98e32"})				This will not work.
db.inventory.find( {"_id": ObjectId("60eaba305e66d126ddb98e32")})	This will work.

Provide your own _id when inserting documents:
db.boyDiapers.insert( [{_id: '101', size: 1, color: 'white', brand: 'toddler tykes' }] )

Let MongoDB generate the _id, but provide your own "id" as per business requirements:
db.boyDiapers.insert( [{id: 'A501', size: 2, color: 'grey', brand: 'toddler tykes' }] )

db.collectionname.count()		# returns # of docs in the coll.

db.coll.findOne()				# returns first matched doc.
db.coll.findOne({"size": 2})	# returns first matched doc.


UPDATE:
update()
updateOne()
updateMany()
replaceOne()

UPDATE tablename
SET col = value
WHERE cond1

Single match and update:
db.girlDiapers.update(
	{ "_id" : ObjectId("6239f5eb543332a41e90ab71") },
	{ $set: {"size" : 2 } }
)


Update all matches:
db.girlDiapers.update(
	{ "size" : 1 },
	{ $set: {"size" : 101 } },
	{ multi: true }
)

db.girlDiapers.updateMany(
	{ "size" : 101 },
	{ $set: {"size" : 1 } },
)

Update many attributes:
db.girlDiapers.updateMany(
	{ "size" : 101, "qty": {$gt: 50} },
	{ $set: {"size" : 1, "color": green" } },
)

Do an "upsert" (Update or Insert) using updateOne:
db.girlDiapers.updateOne(
	{ "size": 11 },
	{ $set: {"size": 11, "color": "green", "brand": "little angels" } },
	{ upsert: true }
)

db.girlDiapers.update(
	{ "size": 111 },
	{ $set: {"size": 111, "color": "pink", "brand": "little angels" } },
	{ upsert: true }
)

updateMany() does not support upsert.

replaceOne():
db.girlDiapers.replaceOne(
	{ "size": 12 },
	{ "size": 12, "color": "pink", "brand": "little angels" },
	{ upsert: true}
)

replaceOne() and updateOne() and update() can be used for upsert operations.


DELETE:
deleteoOne()
deleteMany()

db.girlDiapers.deleteOne(
	{"_id" : ObjectId("623a1b57b88b7d7b92d87374")}
)

db.girlDiapers.deleteMany(
	{"color": "green"}
)

Exception handling using try-catch:
try {
	db.girlDiapers.delete(
		{"_id" : ObjectId("623a1b57b88b7d7b92d87374")}
	)
} catch(e) {
	print(e)
}

How to delete all docs in a collection?:
db.girlDiapers.deleteMany({})
db.girlDiapers.remove({})
db.girlDiapers.remove({ qty: {$gte: 12} })				# Delete all docs that match the condition.
db.girlDiapers.remove({ qty: {$gte: 12} }, true)		# Delete first matched doc that match the condition.

Sorting:
db.girlDiapers.find().sort({"color": 1})		# ASC order
db.girlDiapers.find().sort({"color": -1})		# DESC order

db.girlDiapers.find().sort({"color": 1, "brand": -1})	# sort on multiple attrs.

db.girlDiapers.aggregate({ $sort: {"color": 1} })	# alternate to sort()

Aggregation:
Grouping, aggregations, sorting etc.

SELECT ProductId, SUM(Qty)
FROM OrderDetails
GROUP BY ProductId

// Insert records into the orders collection
db.orders.insertMany([
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-05-30T08:35:52Z"),
    "value": NumberDecimal("231.43"),
	"status": "A"
  },
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-01-13T09:32:07Z"),
    "value": NumberDecimal("99.99"),
	"status": "B"
  },
  {
    "customer_id": "oranieri@warmmail.com",
    "orderdate": ISODate("2020-01-01T08:25:37Z"),
    "value": NumberDecimal("63.13"),
	"status": "A"
  },
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2019-05-28T19:13:32Z"),
    "value": NumberDecimal("2.01"),
	"status": "A"
  },  
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2020-11-23T22:56:53Z"),
    "value": NumberDecimal("187.99"),
	"status": "B"
  },
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2020-08-18T23:04:48Z"),
    "value": NumberDecimal("4.59"),
	"status": "C"
  },
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-12-26T08:55:46Z"),
    "value": NumberDecimal("48.50"),
	"status": "A"
  },
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2021-02-29T07:49:32Z"),
    "value": NumberDecimal("1024.89"),
	"status": "B"
  },
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-10-03T13:49:44Z"),
    "value": NumberDecimal("102.24"),
	"status": "C"
  },
])


db.orders.aggregate([
	{ $match: { status: "A" } },
	{ $group: { _id: "$customer_id, $orderdate", total: { $sum: "$value" } } }
])

db.orders.aggregate([
  {"$match": {
    "orderdate": {
      "$gte": ISODate("2020-01-01T00:00:00Z"),
      "$lt": ISODate("2021-01-01T00:00:00Z"),
    },
  }},
	{ $group: { _id: "$customer_id", total: { $sum: "$value" } } },
	{"$sort": { "orderdate": 1, }},      
])
  
$unwind
Deconstructs an array field from the document and outputs each element separately for the document.
db.inventory.aggregate([ { $unwind: "$sizes" } ] )

db.inventory.insertMany([
{
	"items": [
		{
			"name": "Pens",
			"tags": ["writing", "office", "school", "stationery"],
			"price": NumberDecimal("12.00"),
			"quantity": NumberInt("5")
		},
		{
			"name": "Envelopes",
			"tags": ["stationery", "office"],
			"price": NumberDecimal("1.95"),
			"quantity": NumberInt("10")
		}
	]
},
{
	"items": [
		{
			"name": "Laptops",
			"tags": ["office", "electronics"],
			"price": NumberDecimal("799"),
			"quantity": NumberInt("8")
		},
		{
			"name": "Notepad",
			"tags": ["stationery", "office"],
			"price": NumberDecimal("1.99"),
			"quantity": NumberInt("12")
		}
	]
},
])
 

db.inventory.aggregate( {$unwind: "$items"}, {$unwind: "$items.tags"} )

db.inventory.aggregate( [
	{$unwind: "$items"}, 
	{$unwind: "$items.tags"},
	
	{ $group: {_id: "$items.tags", totalSalesAmount: { $sum: { $multiply: ["$items.price", "$items.quantity"] }} }}
])

Indexes:
Similar to indexes in other DB systems.
In MongoDB, indexes are at the collection level (In RDBMS, it is at table level).
Indexes can be on any field (attr) or subfield (sub-attr) of the documents in a collection.

By default, MongoDB creates an index on the _id attribute. It is called an "_id Index".
You can create indexes on other attributes / fields as well as follows:
db.collectioname.createIndex( { attribute: direction } )

For e.g.;
db.customers.createIndex( { name: 1 } )		# Single field index.
db.customers.createIndex( { name: -1 } )	

Indexes on multiple attrs as:
db.orders.createIndex( { item: 1, quantity: -1 } )		# Compound index.

Give a name to an index:
db.orders.createIndex( 
	{ item: 1, quantity: -1 },
	{ name: "index for orders" }
)

Retrieve indexes on a collection:
db.customers.getIndexes()

Drop an index:
db.customers.dropIndex("index name")

Drop all indexes of a collection:
db.users.dropIndexes()

List all indexes for a DB:
db.getCollectionNames().forEach(function(collection) {
	indexes = db[collection].getIndexes()
	print("Indexes for the collection " + collection + ": ")
	printjson(indexes)
})

db.customers.createIndex({ name: 1} )
db.customers.find( {name: "John" } )


Schemas and Relations:
NoSQL does not have a fixed schema for collections.
We are dealing with a huge number of rows (documents).

// Patron document.		// patrons collection.
{
	"_id": "joe",
	"name": "joe smith"
}

// address document		// patron_addresses collection.
{
	"patron_id": "joe",
	"street": "123 Some Street",
	"city": "Fake city",
	"state": "WA"
	"zip": "12345"
}

Embedded documents:
// patron document.			// patrons collection.
{
	"_id": "joe",
	"name": "joe smith",
	"address": {
		"street": "123 Some Street",
		"city": "Fake city",
		"state": "WA"
		"zip": "12345"
	}
}

NoSQL follows de-normalization!!!

// customer document:		// customers collection.
{
	"_id": 101,
	"firstname": "john",
	"lastname": "smith",
	"city": "Dallas",
	"state": "TX",
	:
	:
}

// order document:			// orders collection.
{
	"_id": "ORD-901",
	"orderDate" : "2022-03-10",
	"customer_id": 101,
	:
	:
}

1. First get a list of orders.
2. for each order, extract the custonmer id
3. Get the customer's data.
4. print the order and customer data together.

// embedded order document:			// orders collection.
{
	"_id": "ORD-901",
	"orderDate" : "2022-03-10",
	"customer": {
		"id": 101,
		"firstname": "john",
		"lastname": "smith"
	},
	:
	:
}

After 6 months, new requirement to do some analysis on customers from states.
// new order embedded document with state:
{
	"_id": "ORD-901",
	"orderDate" : "2022-03-10",
	"customer": {
		"id": 101,
		"firstname": "john",
		"lastname": "smith",
		"state": "TX"
	},
	:
	:
}

Dynamic schema.

Subset pattern: a document within a document.

An example of a subset pattern:
users collection:
{
	"_id": 101,
	"name": "John",
	:
	"ratings_given": [
		{ "movie_id": 1, "rating": 4.5 },
		{ "movie_id": 21, "rating": 7 },
		{ "movie_id": 198, "rating": 6.5 }
	]
}
{
	"_id": 1763,
	"name": "Mary",
	:
}
{
	"_id": 1456,
	"name": "Joe",
	:
}

A movies collection:
{
	"_id": 1,
	"title": "Star Wars - A New Hope",
	"poster": "http://www.someserver.com/images/star_wars_ep4.jpg",
	"genres": ["sci-fi", "action"],
	:
	:
}

// votes collection: _id is auto-generated with ObjectId("......")
{
	"userid": 101,
	"movie": { "movieid", 1, "title": "Star Wars - A New Hope", "rating": 9}
}
{
	"userid": 101,
	"movie": { "movieid", 123, "title": "Tenet", "rating": 6.5}
}
{
	"userid": 101,
	"movie": { "movieid", 785, "title": "The Batman", "rating": 6}
}

One-to-many relationships with document references:
// book document.
{
	"_id": 123456,
	"title": "MongoDB Cookbook",
	"authors": ["John Smith", "Mary Jane"],
	"published_date": "2021-01-28",
	"pages": 345,
	"publisher": {
		"name": "O'Reilly Media",
		"location": "CA",
		"founded": 1980
	}
}
{
	"_id": 789012,
	"title": "Python Made Easy",
	"authors": ["Joe Smith", "Ajay Singala"],
	"published_date": "2020-03-15",
	"pages": 267,
	"publisher": {
		"name": "O'Reilly Media",
		"location": "CA",
		"founded": 1980
	}
}

Split into separate collections with 1..* references:
// publisher document:
{
	"_id": 123
	"name": "O'Reilly Media",
	"location": "CA",
	"founded": 1980,
	"books": [123456, 789012, ...]			// mutable, growing arrays/lists.
}

// book document:
{
	"title": "MongoDB Cookbook",
	"authors": ["John Smith", "Mary Jane"],
	"published_date": "2021-01-28",
	"pages": 345
}
{
	"title": "Python Made Easy",
	"authors": ["Joe Smith", "Ajay Singala"],
	"published_date": "2020-03-15",
	"pages": 267
}

MongoDB Driver- PyMongo
Installation:
On the Windows command prompt / terminal:
pip install pymongo
OR
python -m pip install pymongo
OR
python3 -m pip install pymongo
OR
py -m pip install pymongo

On the Unix command prompt / terminal:
sudo pip install pymongo

How to use PyMongo:
Create a Python program (a .py file) and use as follows:
from pymongo import MongoClient

client = MongoClient()								# connect to the server.
db = client.test									# returns an object pointing to the DB named "test".
collections = db.list_collection_names()
for i in range(len(collections)):
	aCollection = collections[i]
	collObject = db.get_collection(aCollection)
	for doc in collObject.find({"size": 2}):
		print(doc)
		

# Get an object to a DB.
db = client.test
db = client["test"]

# Get an object to a collection.
coll = db.boyDiapers
coll = db["boyDiapers"]
	
pprint.pprint(doc)		# to print the json in pretty format.
coll.insert_one(doc) 	# to insert a document in a collection.
coll.find({})			# returns a list of matching docs.
coll.find_one({})		# returns a single matching doc.
doc_id = collection.insert_one(doc).inserted_id		# returns the id of the newly inserted doc.

To Search on the _id, you have import the ObjectId module as follows:
from bson.objectid import ObjectId

Then use it as:
coll.find_one( { "_id" : ObjectId("23474hfr8484ofhfh"} )
coll.find( { "_id" : ObjectId("23474hfr8484ofhfh"} )

Avoid using find() when searching based on _id.

Bulk insert:
coll.insert_many(docs)
Returns an object that also contains a list ObjectIds (in an attr called "inserted_ids") of the newly inserted docs.
result = coll.insert_many(docs)
print(result.inserted_ids)

Counting docs:
>>> collection.count_documents({})
>>> collection.count_documents({"size": 4})

Sorting:
>>> for doc in collection.find().sort("color"):
...    print(doc)

by default, sort order is ASC.
>>> for doc in collection.find().sort("color", 1):		# ASC
...    print(doc)
>>> for doc in collection.find().sort("color", -1):		# DESC
...    print(doc)

Query with equality (projection) operators:
>>> for doc in collection.find({"size" : {"$gt" : 2}}):
...    print(doc)

Create a collection:
db.create_collection("collection name")

E.g.;
from datetime import datetime

db.create_collection("posts")
posts = db["posts"]
docs = [
	{"author": "John", "text": "This is a post by John", "tags": ["bulk", "insert"], "date": datetime(2022,3,24,11,45) },
	{"author": "Mary", "text": "This is a post by Mary", "tags": ["bulk", "insert"], "date": datetime(2022,3,22,14,23) }
]
result = posts.insert_many(docs)
print(result.inserted_ids)

dt = datetime(2022,3,23)
for post in posts.find({"date": {"$lt": dt}}):
   print(post)
   
Projection operators:
Comparison:
$eq
$gt
$gte
$lt
$lte
$ne

Logical:
$and
$or
$not

Indexes:
from pymongo import ASCENDING, DESCENDING
posts.create_index([("author", ASCENDING)])

Get list of indexes on a collection:
collection.index_information()

For e.g.;
posts.index_information()

To get only the names of indexes:
list(posts.index_information())

Delete:
from bson.objectid import ObjectId
result = inv.delete_one({"_id": ObjectId("623a2bf4543332a41e90abaa")})
print(result.deleted_count)

result = boyDiapers.delete_many({"size": 901})
print(result.deleted_count)

Update:
upate_one()
update_many()

result = boyDiapers.update_one({"size": 100}, {"$set": {"color": "green"}})
result.matched_count

result = boyDiapers.update_many({"size": 4}, {"$set": {"color": "gray"}})
result.matched_count
result.modified_count

Replace:
result = boyDiapers.replace_one({"_id" : ObjectId("623c8c8865aefa831c50790a"),}, {"size": 4, "color": "brown", "brand": "prince"})
result.matched_count
result.modified_count

Limit:
coll.find(limit=5)

Projection:
Limit the columns returned.
Display all columns except the _id column:
for doc in inv.find(projection = {"_id": False}):
   print(doc)
   
Display only the _id:
for doc in inv.find(projection = {"_id": True}):
   print(doc)

for doc in inv.find(projection = {"_id": True, "item": True}):
   print(doc)


Between 01-Jan-2022 and 31-03-2022:
docs = posts.find({"$and": [{"date": {"$gte": datetime(2022,1,1)}}, {"date": {"$lte": datetime(2022,3,31)}}] })
for aPost in docs:
   print(aPost)


MongoDB Connection String:
localhost:27017
mongodb://server:port
mongodb://username:password@server:port
mongodb://server:port/dbname
mongodb://username:password@server:port/dbname

mongodb://localhost:27017
mongodb://acme.mongodbserver.com:27017
mongodb://acme.mongodbserver.com:9876
mongodb://admin:admin@acme.mongodbserver.com:27017
mongodb://localhost:27017/inventory
mongodb://acme.mongodbserver.com:27017/products
mongodb://admin:admin@acme.mongodbserver.com:27017/products

client = MongoClient('mongodb://server:port')
client = MongoClient('mongodb://localhost:27017')
client = MongoClient('mongodb://acme.mongodbserver.com:27017')
client = MongoClient('mongodb://admin:admin@acme.mongodbserver.com:27017')

client = MongoClient('mongodb://server:port/products')
client = MongoClient('mongodb://localhost:27017/products')
client = MongoClient('mongodb://acme.mongodbserver.com:27017/products')
client = MongoClient('mongodb://admin:admin@acme.mongodbserver.com:27017/products')

Group By - Having:
#It's the equivalent of the following SQL instruction:
# SELECT COUNT(*) FROM Table
# GROUP BY your_field
# HAVING COUNT(*) > N
query = db.collection.aggregate([

    { 
      "$group": { "_id": "$your_field", #GROUP BY your_field
    			"count": {"$sum":1} }   #COUNT(*)
    },
    
    { "$match": { "count": { "$gt": N } } } #HAVING COUNT(*) > N
])

query = db.orderDetails.aggregate([
    { 
      "$group": { "_id": "$productId",
    			"productCount": {"$sum":1} } 
    },
    
    { "$match": { "productCount": { "$gt": 10 } } }
])

Similar to:
SELECT ProductId, COUNT(*) as 'productCount'
FROM OrderDetails
GROUP BY ProductId
HAVING productCount > 10

