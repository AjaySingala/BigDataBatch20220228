MongoDB:
	It is not an RDBMS!
	It is a NoSQL database.
	"Not Only SQL" or "Not SQL".
	You cannot run SQL queries like:
		SELECT * FROM tablename....
		INSERT INTO tablenbame(...) VALUES (...)
	In RDBMS, we have tables, rows.
	In NoSQL, we have collections, documents.
	The format in which the docs are stored in the DB is JSON format.
	
	In RDBMS, we may have:
		PRODUCTS table: ProductID, ProductName, CategoryID
		CATEGORIES table: CategoryID, CategoryName
		
	In NoSQL, we will have:
		ProductsCategory collection: productId, productname, categoryid, categoryname
		
	NoSQL is a non-relational DB. There is no PK-FK relations.
	Avoid joins in a NoSQL db.
	The performance of fetching data is much faster.
	NoSQL dbs are catered towards processing and handling of large datasets.
	NoSQL are easier to scale, and are meant for distributed processing.
	NoSQL concept was introduced in the late 90s, around 1998.
	SQL: there is predefined schema. NoSQL: there is no predefined schema. NoSQL is unstructured.
	SQL: MS SQL Server, Oracle, Postgres etc. NoSQL: MongoDB, Hbase, Cassandra, CouchBase.
	Most NoSQL are opensource.
	SQL: used for solving the ACID problems. NoSQL: solving the problem of availability of data.
	SQL: ACID. NoSQL: BASE - Basically Available, Soft state, Eventually consistent.
	BASE:
		Basically Available: The sysytem is guranteed to be available in the event of a failure. This is due to the distributed nature of NoSQL DBs.
		Soft state: The state of the data could change without  application interactions due to eventual consistency.
		Eventual consitency: The system will be eventually consistent after data is given to the system (DB). The data will be replicated to different nodes and will eventually reach a consistent state.
		
MongoDB:
	Open source DB.
	Written in C++.
	Fully scalable.
	It does not support SQL syntax (because it is a NoSQL DB).
	It supports a rich, ad-hoc query language of its own.
	It stores data as documents in collections.
	It is a "document oriented database".
	
	
To start MongoDB, open a command prompt / terminal and start the server:
•	Create the database directory. Open a command prompt and run:
mkdir c:\data\db
•	Start MongoDB from the command line with:
"C:\Program Files\MongoDB\Server\4.4\bin\mongod.exe" --dbpath="c:\data\db"
•	Open another command prompt and connect to MongoDB with:
"C:\Program Files\MongoDB\Server\4.4\bin\mongo.exe"

Commands:
show dbs
db.test.find()			# SELECT * FROM test
db.dropDatabase()		# delete current database.
use <dbname>
show tables				# display table (collection) names.
db.getCollectionNames()	# list of collections
db.createCollection("coll_name")	# create a new collection named "coll_name")
db.collectioname.drop()		# drop/delete a collection.
Insert docs in a collection:
db.collectioname.insert( data )	# The data has to be in JSON format.
For e.g.;
db.boyDiapers.insert( [{size: 1, color: 'blue', brand: 'toddler tykes' }] )
db.girlDiapers.insert( [{size: 1, color: 'white', brand: 'little angel' }, {size: 1, color: 'pink', brand: 'little angel' }, {size: 2, color: 'white', brand: 'little angel' }] )

db.girlDiapers.insert( [{size: 9, color: 'white', brand: 'toddler tykes' }, {size: 9, color: 'pink', brand: 'toddler tykes' }, {size: 10, color: 'white', brand: 'toddler tykes' }, {size: 10, color: 'pink', brand: 'toddler tykes' }] )

all documents in MongoDB have a built-in "key" attribute called "_id", the value of which is auto-generated by MongoDB.

db.girlDiapers.find()	# display docs in the collection.
	By default, find() displays the first 20 docs.
	
db.girlDiapers.find().pretty()		# display the JSON docs in a "pretty" format.

SELECT * FROM girDiapers
WHERE Size = 2

db.girlDiapers.find({"size": 2})

Things to remember about MongoDB:
Max size of a doc is 16MB.
BSON: Binary JSON. Max size 16MB.
Max no. of indexes on a collection is 64.
It is a document-oriented DB.
Stores data in collections and not tables.
Data is in documents, not rows.
It uses dynamic schema.
MongoDB client drivers exist for many programming languages like Python, Scala, Java etc.
It does not support SQL. But it has its own non-SQL, ad-hoc query syntax.
Usually used in content management system, social media sites/apps, analytics, ecommerce, logging.
It does not support transactions. Noi ACID. But there is BASE.
It also supports caching of data. It keeps all most recently used data in RAM.


INSERT documents:
db.girlDiapers.insert()
db.girlDiapers.insertOne( {} )
db.girlDiapers.insertMany([{}])
db.girlDiapers.insertMany([{}, {}, {}])

db.girlDiapers.find()
db.girlDiapers.find({})
db.girlDiapers.find({ cond1, cond2 })
db.girlDiapers.find({ "size": 1, "color": "white" })

Match attribute in a complex dpocument (json within json):
db.inventory.find({ "size.uom": "cm" })
db.inventory.find({ "size.h": { $gt : 10 } })			> 10
db.inventory.find({ "size.h": { $gte : 10 } })			>= 10
db.inventory.find({ "size.h": { $lt : 10 } })			< 10
db.inventory.find({ "size.h": { $lte : 10 } })			<= 10
db.inventory.find({ "size.h": { $eq : 10 } })			== 10
db.inventory.find({ "size.h": { $ne : 10 } })			!= 10

SELECT Id, Name FROM table
db.inventory.find({ "size.uom": "cm" }, {"item": 1})		show only item attr.
db.inventory.find({ "size.uom": "cm" }, {"item": 0})		show all attrs except item.
db.inventory.find({ "size.uom": "cm" }, {"qty": 0, "size": 0})		show all attrs except qty and size.

AND:
db.girlDiapers.find({ "size": 1, "color": "white" })
db.girlDiapers.find( {$and: [{ "size": 1}, {"color": "white" }] })
db.girlDiapers.find( {$or: [{ "size": 1}, {"color": "white" }] })

SELECT Item FROM inventory
db.inventory.find( {}, { "item": 1 } )

Search based on the built-in auto-generated id:
db.inventory.find( {"_id": "60eaba305e66d126ddb98e32"})				This will not work.
db.inventory.find( {"_id": ObjectId("60eaba305e66d126ddb98e32")})	This will work.

Provide your own _id when inserting documents:
db.boyDiapers.insert( [{_id: '101', size: 1, color: 'white', brand: 'toddler tykes' }] )

Let MongoDB generate the _id, but provide your own "id" as per business requirements:
db.boyDiapers.insert( [{id: 'A501', size: 2, color: 'grey', brand: 'toddler tykes' }] )

db.collectionname.count()		# returns # of docs in the coll.

db.coll.findOne()				# returns first matched doc.
db.coll.findOne({"size": 2})	# returns first matched doc.


UPDATE:
update()
updateOne()
updateMany()
replaceOne()

UPDATE tablename
SET col = value
WHERE cond1

Single match and update:
db.girlDiapers.update(
	{ "_id" : ObjectId("6239f5eb543332a41e90ab71") },
	{ $set: {"size" : 2 } }
)


Update all matches:
db.girlDiapers.update(
	{ "size" : 1 },
	{ $set: {"size" : 101 } },
	{ multi: true }
)

db.girlDiapers.updateMany(
	{ "size" : 101 },
	{ $set: {"size" : 1 } },
)

Update many attributes:
db.girlDiapers.updateMany(
	{ "size" : 101, "qty": {$gt: 50} },
	{ $set: {"size" : 1, "color": green" } },
)

Do an "upsert" (Update or Insert) using updateOne:
db.girlDiapers.updateOne(
	{ "size": 11 },
	{ $set: {"size": 11, "color": "green", "brand": "little angels" } },
	{ upsert: true }
)

db.girlDiapers.update(
	{ "size": 111 },
	{ $set: {"size": 111, "color": "pink", "brand": "little angels" } },
	{ upsert: true }
)

updateMany() does not support upsert.

replaceOne():
db.girlDiapers.replaceOne(
	{ "size": 12 },
	{ "size": 12, "color": "pink", "brand": "little angels" },
	{ upsert: true}
)

replaceOne() and updateOne() and update() can be used for upsert operations.


DELETE:
deleteoOne()
deleteMany()

db.girlDiapers.deleteOne(
	{"_id" : ObjectId("623a1b57b88b7d7b92d87374")}
)

db.girlDiapers.deleteMany(
	{"color": "green"}
)

Exception handling using try-catch:
try {
	db.girlDiapers.delete(
		{"_id" : ObjectId("623a1b57b88b7d7b92d87374")}
	)
} catch(e) {
	print(e)
}

How to delete all docs in a collection?:
db.girlDiapers.deleteMany({})
db.girlDiapers.remove({})
db.girlDiapers.remove({ qty: {$gte: 12} })				# Delete all docs that match the condition.
db.girlDiapers.remove({ qty: {$gte: 12} }, true)		# Delete first matched doc that match the condition.

Sorting:
db.girlDiapers.find().sort({"color": 1})		# ASC order
db.girlDiapers.find().sort({"color": -1})		# DESC order

db.girlDiapers.find().sort({"color": 1, "brand": -1})	# sort on multiple attrs.

db.girlDiapers.aggregate({ $sort: {"color": 1} })	# alternate to sort()

Aggregation:
Grouping, aggregations, sorting etc.

SELECT ProductId, SUM(Qty)
FROM OrderDetails
GROUP BY ProductId

// Insert records into the orders collection
db.orders.insertMany([
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-05-30T08:35:52Z"),
    "value": NumberDecimal("231.43"),
	"status": "A"
  },
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-01-13T09:32:07Z"),
    "value": NumberDecimal("99.99"),
	"status": "B"
  },
  {
    "customer_id": "oranieri@warmmail.com",
    "orderdate": ISODate("2020-01-01T08:25:37Z"),
    "value": NumberDecimal("63.13"),
	"status": "A"
  },
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2019-05-28T19:13:32Z"),
    "value": NumberDecimal("2.01"),
	"status": "A"
  },  
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2020-11-23T22:56:53Z"),
    "value": NumberDecimal("187.99"),
	"status": "B"
  },
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2020-08-18T23:04:48Z"),
    "value": NumberDecimal("4.59"),
	"status": "C"
  },
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-12-26T08:55:46Z"),
    "value": NumberDecimal("48.50"),
	"status": "A"
  },
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2021-02-29T07:49:32Z"),
    "value": NumberDecimal("1024.89"),
	"status": "B"
  },
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-10-03T13:49:44Z"),
    "value": NumberDecimal("102.24"),
	"status": "C"
  },
])


db.orders.aggregate([
	{ $match: { status: "A" } },
	{ $group: { _id: "$customer_id, $orderdate", total: { $sum: "$value" } } }
])

db.orders.aggregate([
  {"$match": {
    "orderdate": {
      "$gte": ISODate("2020-01-01T00:00:00Z"),
      "$lt": ISODate("2021-01-01T00:00:00Z"),
    },
  }},
	{ $group: { _id: "$customer_id", total: { $sum: "$value" } } },
	{"$sort": { "orderdate": 1, }},      
])
  
$unwind
Deconstructs an array field from the document and outputs each element separately for the document.
db.inventory.aggregate([ { $unwind: "$sizes" } ] )

db.inventory.insertMany([
{
	"items": [
		{
			"name": "Pens",
			"tags": ["writing", "office", "school", "stationery"],
			"price": NumberDecimal("12.00"),
			"quantity": NumberInt("5")
		},
		{
			"name": "Envelopes",
			"tags": ["stationery", "office"],
			"price": NumberDecimal("1.95"),
			"quantity": NumberInt("10")
		}
	]
},
{
	"items": [
		{
			"name": "Laptops",
			"tags": ["office", "electronics"],
			"price": NumberDecimal("799"),
			"quantity": NumberInt("8")
		},
		{
			"name": "Notepad",
			"tags": ["stationery", "office"],
			"price": NumberDecimal("1.99"),
			"quantity": NumberInt("12")
		}
	]
},
])
 

db.inventory.aggregate( {$unwind: "$items"}, {$unwind: "$items.tags"} )

db.inventory.aggregate( [
	{$unwind: "$items"}, 
	{$unwind: "$items.tags"},
	
	{ $group: {_id: "$items.tags", totalSalesAmount: { $sum: { $multiply: ["$items.price", "$items.quantity"] }} }}
])

Indexes:
Similar to indexes in other DB systems.
In MongoDB, indexes are at the collection level (In RDBMS, it is at table level).
Indexes can be on any field (attr) or subfield (sub-attr) of the documents in a collection.

By default, MongoDB creates an index on the _id attribute. It is called an "_id Index".
You can create indexes on other attributes / fields as well as follows:
db.collectioname.createIndex( { attribute: direction } )

For e.g.;
db.customers.createIndex( { name: 1 } )		# Single field index.
db.customers.createIndex( { name: -1 } )	

Indexes on multiple attrs as:
db.orders.createIndex( { item: 1, quantity: -1 } )		# Compound index.

Give a name to an index:
db.orders.createIndex( 
	{ item: 1, quantity: -1 },
	{ name: "index for orders" }
)

Retrieve indexes on a collection:
db.customers.getIndexes()

Drop an index:
db.customers.dropIndex("index name")

Drop all indexes of a collection:
db.users.dropIndexes()

List all indexes for a DB:
db.getCollectionNames().forEach(function(collection) {
	indexes = db[collection].getIndexes()
	print("Indexes for the collection " + collection + ": ")
	printjson(indexes)
})

db.customers.createIndex({ name: 1} )
db.customers.find( {name: "John" } )


Schemas and Relations:
NoSQL does not have a fixed schema for collections.
We are dealing with a huge number of rows (documents).

// Patron document.		// patrons collection.
{
	"_id": "joe",
	"name": "joe smith"
}

// address document		// patron_addresses collection.
{
	"patron_id": "joe",
	"street": "123 Some Street",
	"city": "Fake city",
	"state": "WA"
	"zip": "12345"
}

Embedded documents:
// patron document.			// patrons collection.
{
	"_id": "joe",
	"name": "joe smith",
	"address": {
		"street": "123 Some Street",
		"city": "Fake city",
		"state": "WA"
		"zip": "12345"
	}
}

NoSQL follows de-normalization!!!

// customer document:		// customers collection.
{
	"_id": 101,
	"firstname": "john",
	"lastname": "smith",
	"city": "Dallas",
	"state": "TX",
	:
	:
}

// order document:			// orders collection.
{
	"_id": "ORD-901",
	"orderDate" : "2022-03-10",
	"customer_id": 101,
	:
	:
}

1. First get a list of orders.
2. for each order, extract the custonmer id
3. Get the customer's data.
4. print the order and customer data together.

// embedded order document:			// orders collection.
{
	"_id": "ORD-901",
	"orderDate" : "2022-03-10",
	"customer": {
		"id": 101,
		"firstname": "john",
		"lastname": "smith"
	},
	:
	:
}

After 6 months, new requirement to do some analysis on customers from states.
// new order embedded document with state:
{
	"_id": "ORD-901",
	"orderDate" : "2022-03-10",
	"customer": {
		"id": 101,
		"firstname": "john",
		"lastname": "smith",
		"state": "TX"
	},
	:
	:
}

Dynamic schema.

Subset pattern: a document within a document.

An example of a subset pattern:
users collection:
{
	"_id": 101,
	"name": "John",
	:
	"ratings_given": [
		{ "movie_id": 1, "rating": 4.5 },
		{ "movie_id": 21, "rating": 7 },
		{ "movie_id": 198, "rating": 6.5 }
	]
}
{
	"_id": 1763,
	"name": "Mary",
	:
}
{
	"_id": 1456,
	"name": "Joe",
	:
}

A movies collection:
{
	"_id": 1,
	"title": "Star Wars - A New Hope",
	"poster": "http://www.someserver.com/images/star_wars_ep4.jpg",
	"genres": ["sci-fi", "action"],
	:
	:
}

// votes collection: _id is auto-generated with ObjectId("......")
{
	"userid": 101,
	"movie": { "movieid", 1, "title": "Star Wars - A New Hope", "rating": 9}
}
{
	"userid": 101,
	"movie": { "movieid", 123, "title": "Tenet", "rating": 6.5}
}
{
	"userid": 101,
	"movie": { "movieid", 785, "title": "The Batman", "rating": 6}
}

One-to-many relationships with document references:
// book document.
{
	"_id": 123456,
	"title": "MongoDB Cookbook",
	"authors": ["John Smith", "Mary Jane"],
	"published_date": "2021-01-28",
	"pages": 345,
	"publisher": {
		"name": "O'Reilly Media",
		"location": "CA",
		"founded": 1980
	}
}
{
	"_id": 789012,
	"title": "Python Made Easy",
	"authors": ["Joe Smith", "Ajay Singala"],
	"published_date": "2020-03-15",
	"pages": 267,
	"publisher": {
		"name": "O'Reilly Media",
		"location": "CA",
		"founded": 1980
	}
}

Split into separate collections with 1..* references:
// publisher document:
{
	"_id": 123
	"name": "O'Reilly Media",
	"location": "CA",
	"founded": 1980,
	"books": [123456, 789012, ...]			// mutable, growing arrays/lists.
}

// book document:
{
	"title": "MongoDB Cookbook",
	"authors": ["John Smith", "Mary Jane"],
	"published_date": "2021-01-28",
	"pages": 345
}
{
	"title": "Python Made Easy",
	"authors": ["Joe Smith", "Ajay Singala"],
	"published_date": "2020-03-15",
	"pages": 267
}

