Scala:
After Python, it is one of most popular programming languages for Big Data.
Java-based, it runs on the JVM.
Not derived from "La Scala" - Italian staircase / ladder.
It is an abbreviation for SCAlable LAnguage
Professor Martin Odersky in ~2003.
High-performance, scalable, functional programming language, Object Oriented Language.
It runs on the JVM - Java Virtual Machine.

Scala is an Object Oriented Language:
It is a pure OO language in the sense that every value in Scala is an object.
Types & object behaviors are described by classes and traits.

Achieve inheritance (classes are extended) by subclassing.

Scala is Functional:
Every function is a value, and every value is an object, so ultimately, every function is also an object.

Scala provides Anonymous Functions, it supports Higher-Order Functions., also supports nested functions.

Scala is Statically typed:
Most progamming languages require you to specify a type, but Scala does not expect you to do that.
Scala has it's own defined sets of types.

It runs on the JVM - Java Virtual Machine:
You write code in Scala.
When you compile it, it is convered into Java Byte Code, which is then executed by the JVM.
Compiling is done using the command "scalac" and execution is done using "scala".

Create a source code file: first.scala
scalac will compile it and create first.class
scala will execute the byte code first.class

Scala can execute Java code as well.

Scala vs Java:
- All types are objects.
- Type inference.
- Nested functions.
- Functions are objects.
- Traits.

Functional Programming:
-----------------------
Uses functions as a building block of programs.
We strive to use "pure" functions and immutable values.

Immutability:
State (value) of variables (objects) cannot be changed. We can create a new object, but we cannot modify the existing object's state.

Pure Functions:
A pure function has tow key properties:
1) It always returns the same value for the same input.
2) It has no side effects. A function does not interact with anything (variable/object) outside of the function. This could be global variables, mutable objects, I/O operations etc.

Functions are treated as "First Class Citizens":
------------------------------------------------
Scala treats all functions as First Class functions/citizens by default.
Functions are values:
- a function can be assigned to a variable.
- it can be passed as an argument to other function.
- it can be returned as a value from other functions.

function add(a, b) {
	some code
	:
}


objectAdd = add
objectAdd(10,20)

function math(fn, x, y) {
	fn(x,y)
}

math(objectadd, 10,20)

function foo() {
	fnAdd = add
	:
	:
	:
	return fnAdd

}

Higher-Order Functions (HOF):
-----------------------------
A HOF is a function that has at least one of the following properties:
1. Takes one or more functions as parameters.
2. Returns a function as a result.

def calcAnything(number: Int, calcFunction: Int => Int): Int = calcFunction(number)

def calcSquare(num: Int): Int = num * num

def calcCube(num: Int): Int = num * num * num

val squareResult = calcAnything(2, calcSquare)			// returns 4.
val cubeResult = calcAnything(3, calcCube)				// returns 27.

Concpets of Functional Programming:
- Pure functions
- Variables are immutable
- Functions are First-class and can be Higher-order
- Recursion


Installing Scala:
JDK 8
SBT = Scala Build Tool
	Alternative to scalac and scala
Scala

JDK: https://www.oracle.com/java/technologies/downloads/#java8-windows (select x64 installer)
Scala: https://www.scala-lang.org/download/2.13.6.html
SBT: https://github.com/sbt/sbt/releases/download/v1.5.5/sbt-1.5.5.msi

Ensure the following Environment variables are created and properly initialized:
JAVA_HOME: path to the JDK folder. For e.g.; C:\Program Files\Java\jdk-11.0.12
In the PATH variable, add these:
	Path to the JDK's bin folder. For e.g.; C:\Program Files\Java\jdk-11.0.12\bin
	Path to the SBT bin folder. For e.g.; C:\Program Files (x86)\sbt\bin
	Path to the Scala bin folder. For e.g.; C:\Program Files (x86)\scala\bin
	
Scala execution modes:
- Interactive Mode (REPL)
	- Command/Terminal window
- Script Mode
	- IDE (VS Code)
	- Using scalac, scala
	- sbt
	
Scala is case-sensitive!

sbt project structure:
	project folder
		project
		target
		src
			main
				scala
				

Create a new folder
run sbt
From another command window or File Explorer:
	create folder structure in the new folder mentioned above:
			project
			target
			src
				main
					scala
						<package folder> For e.g.; examples

Using an editor, create a .scala file in src\main\scala\examples

From the sbt prompt, execute the command "compile".
Then, from the sbt prompt, execute the command "run".

Command to create a sbt project for Scala with folders and build.sbt file:
sbt new scala/scala-seed.g8 (preferred)
OR 
sbt new sbt/scala-seed.g8


The folder where the build.sbt file is located is the "root" folder of your project.
This root folder will also have the "src" folder.
 
In VSC, install the following extensions:
- Scala (Metals) by Scalameta
- Scala (sbt) by Lightbend
- Scala Syntax (official) by Scala-Lang
	
To declare a variable, use either val or var. For e.g.:
val x = 10
val name = "Ajay Singala"

Scala REPL, Variables and Values:
---------------------------------
REPL: Read Evaluate Print Loop
Scala is not really an interpreted language. It is a compiled language.
A literal:  data that appears as-is directly in the code. For e.g.; the number 7, the character A, or the string "Hello".
A value: is an immutable, typed storage unit. A value can be assigned data when it is defined, but cannot be reassigned.
val x = 10
x = 20			// Not possible.
A variable: is a mutable, typed storage unit. A variable can be assigned data  when it is defined, and can also be reassigned data at any time.
var x = 10
x = 20			// Will work.

Scala Data Types:
-----------------
Basic Data Types: (Value Types)
Boolean:	true or false
Int
Char
Float
Double
Byte
Short
Long

(Reference Types)
String
List
Array
Class

Advanced Data Types:
Unit:	Means to no value.
Null:	Null or empty reference.
Nothing:Subtype of every other type, includes no values.
Any:	Supertype of all other type; any object is of type Any.
AnyRef: Supertype of any reference type.

Passing by value:
def foo(x: Int) {
	x = x * 2
	println(x)	// 20
}

var i = 10
println(i)		// 10
foo(i)
prinln(i)		// 10

Basic Syntax and Terms in Scala:
--------------------------------
Object - Objects have states and behaviors. An object is a runtime instance of a Class. For e.g.; a Dog has states: color, name, breed. has behavior: wagging, barking, eating, running.
Class: A template / blueprint, which describes the behaviors/states of the class.
Fields: Each object has its own unique sets of instance variables, known as fields.
	dogA - Max, black, German Shepherd.
	dogB - Tommy, brown, Terrier.
Traits: 
	Most modern programming languages do not allow multiple inheritance.
	But there can be situations where you want to inherit from multple classes.
	In such scenarios, we use Traits (in other languages, equivalent are abstract classes and interfaces). 
	Traits are very similar to classes.
	A trait encapsulates (has) methods and field definitions, just like a class.
	But, in a trait, you can define a method without it's implementation (just provide the signature).
		- such methods are known as abstract methods.

Scala Coding Conventions:
-------------------------
Case sensitivity - scala is case sensitive.
Class names: Capitalized words For e.g.; class MyFirstClass
Method names: start with a lower case For e.g.; def getCustomerName()
Program Filename: the filename must be same as the object created in the program. For e.g.; if the code is this:
object MyFirst {
	def main(args: Array[String]) {
		:
		:
	}	
}

Then the filename should be MyFirst.scala

Starting point: the main method as follows:
	def main(args: Array[String]) {

	}

Scala Identifiers:
------------------
Names used for objects, classes, functions, variables are called Identifiers.
Legal alphanumeric identifiers: Should start with either an alphabet or an underscore ( _ )
	- For e.g.; age, salary, _firstName, _first_name, last_name, __order_number 
Illegal identifiers: Cannot start with $, -, number
	- For e.g.; $salary, 123age, -firstname
	
Scala Keywords:
---------------
def	do	while	if	else	class	extends		false	true	import	this	throw	val	var	yield	lazy	abstract	case
match	return	with finally	trait	object	override	protected	sealed	new	Try	catch	for 
: 	=	=> @ <-

Variable Declaration:
Either use val or var.
val a = 10
var name = "Ajay"

Variable Data Types (semi-colon is optional):
val x: Int = 10;
var name: String = "John";

Multiple assignments:
val (num1: Int, name: String) = (40, "John")

You cannot declare a variable without an initial value. The following will give an error:
val a: Int;
val name: String;

To define character vaiables, use single quotes and provide a single character only! For e.g.:
val aChar = 'A'

Using multiple expressions with the help of curly braces {}:
val x  = { val a = 100; val b = 200; a + b }
println(x)

OR on multiple lines:
scala> val x = {
     | val a = 100
     | val b = 200
     | a + b
     | }

Comments:
Using double forward slash: //

Lazy Loading:
Lazy initialization means the value is not assigned "now" (during declaration).
It will be assigned when the variable is first accessed.

If you are going to store millions of values into a variable, you may not want to do this when a program starts (or a function starts).
You just lazy load the data and the actualy loading / assignment of the data will happen ONLY when the variable is accessed for the first time after the declaration.

Converting Data Type:
val strNum = "10"
val i: Int = strNum			// Error.
val i: Int = strNum.toInt	// Works!

Strings:
--------
val msg = "This is line one. \nThis is line two."
val greeting = "Hello " + "World"		// Concat.
val greeting: String = Hello World

scala> val isMatching = (greeting == "Hello World")
val isMatching: Boolean = true

scala> val isMatching = (greeting == "Hello, World")
val isMatching: Boolean = false

scala> val ttt = "Na" * 16 + "Something"
val ttt: String = NaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaSomething

scala> val ttt = "Na" + 16 + "Something"
val ttt: String = Na16Something

Multiline strings using """text goes here""" (triple quotes):
val msg = """For formatting text and adding a new line, 
specify a \n. And for tabs, specify \t.
This way, you can format your text properly.
""" 

Triple quotes do not encode/decode escape sequences. The above will print \n and \t and not a newline and tab.

String interpolation:
scala> val a = 10
val a: Int = 10

scala> val b= 5
val b: Int = 5

scala> val c = a / b
val c: Int = 2

Concat:
scala> println("a = " + a + ". b = " + b + ". c = " + c)
a = 10. b = 5. c = 2

Use interpolation instead:
scala> println(s"a = $a. b = $b. c = $c")
a = 10. b = 5. c = 2

scala> val item = "pencil"
val item: String = pencil

scala> println(s"There are 4 $item")
There are 4 pencil

scala> println(s"There are 4 ${item * 3}")
There are 4 pencilpencilpencil

if-else expression block:
-------------------------
if usage:
---------
if(cond) <expression>

if(a == b) {
	// do something
	// more code
}


val soemVariable = (a == b)

if-else usage:
--------------

if(cond) {
	// code
}
else {
	// code
}

if( x > y) x else y
Or
if(x > y) {
	x
}
else {
	y
}

if-else-if usage:
-----------------
if(cond1) {
	// expression
}
else if(cond2) {
	// expr
}
else if(cond3) {
	// expr
}
else {
	// expr
}

Match Expressions:
------------------
An efficient alternative to if-else-if statements.
Similar to switch-case statement in C#, Java etc.
        status match {
            case "New" => {
                println("A new document...")
            }
            case "In Progress" => println("The document is being reviewed...")
            case "Approved" => println("The document is Approved...")
            case "Rejected" => println("The document is Rejected...")
            case _ => println("Status unknown!!!")		// Using wildcard.
        }

Example:		
scala> val x = 10
val x: Int = 10

scala> val y = 20
val y: Int = 20

scala> val max = x > y match {
     | case true => x
     | case false => y
     | }
val max: Int = 20


Example:		
	chkDOW("MON")
	chkDOW("FRI")
	chkDOW("SAT")
	
    def chkDOW(day: String) {
        println(s"\nChecking Day of the week $day...")
        day match {
            case "MON" | "TUE" | "WED" | "THU" |"FRI" => println("Weekday!")
            case "SAT" | "SUN" => println("Weekend!!!")
        }
    }
	
Mathcing with Pattern Guards:
scala> val result : String = null
val result: String = null

scala> result match {
     | case s if s != null => println(s"The value is $s")
     | case s => println("ERROR! Value is null!!!")
     | }
ERROR! Value is null!!!

Here, "s" will have the value of "result" and in the 1st case, it checks if it is != null.

Loops:
------
The "for" loop:
for( <identifier> <- <iterator>) <expression>
for( <identifier> <- <iterator>) { <expression> ... }

For e.g.:
for(i <- 1 to 7) {
	println(i)
}

The "yield" keyword:
for(i <- 1 to 7) yield {
	s"Day $i"
}

For every value iterated in a for lopo, yield generates a value and remembers it in an internal (hidden) buffer.
When the loop completes, it returns this hidden buffer.
this hidden buffer (collection) that is returned is of the same type that we are iterating on. If we were iterating on a List, it returns a List. If we were iterating on a Map, it will return a Map.

Using guards with "for" loop:
for(i <- 1 to 10 if i > 5) yield {
	i
}

for(i <- 1 to 10 if i % 2 == 0) yield {
	i
}

Use "until" instead of "to" in for loop:
for(i <- 1 until 10) print(i)

"until" means upto the number/value on the right side, but not including that number/value.

Use "by" to specify an increment:
for(i <- 1 to 10 by 2) print(i)
This will print nos. 1,3,5,7,9 skipping every alternate value.

for( <identifier> <- m to n [guard])[yield] <expression>
for( <identifier> <- m until n [guard]) [yield] <expression>
for( <identifier> <- m to n [by <increment>])[yield] <expression>
for( <identifier> <- m until n [by <increment>])[yield] <expression>

Nested iterators:
for { x <- 1 to 2
 y <- 1 to 3 }
 { print(s"($x,$y)  ") }

Similar to:
for(x < 1 to 2) {
	for(y <- 1 to 3) {
		print(s"($x,$y) ")
	}
}

while loop:
while(<condition>) <expression>
while(<condition>) {
	<expression>
	// remember to increment / decrement
}

var x = 1
while(x <= 10) {
	print(s"$x:")
	// x = x + 1
	x += 1
}

var x = 10
while(x > 0) {
	print(s"$x:")
	x -= 1
}

var x = 1
while(x <= 10) {
	print(s"$x:")
	x += 1
	if(x > 5) {
		break
	}
}

Breaking out of a loop in Scala:
1) You have to create "named loops".
import scala.util.control._

object BreakDemo {
  def main(args: Array[String]) {
    var a = 0
    val nums = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    var myLoop = new Breaks

    myLoop.breakable {
      for (a <- nums) {
        print(s"$a: ")

        if (a > 5) {
          myLoop.break
        }
      }
    }
  }
}

2) without named loops:
  def demo2() {
    println("\nDemo 2...")
    // This requires: import scala.util.control.Breaks._
    breakable {
      for (i <- 1 to 10) {
        if (i == 6) {
          break
        }
        print(s"$i: ")
      }
    }
  }

I either case, you have to define a "breakable" expression block.

Breaking Nested Loops:
def demo3() {
    println("\nDemo 3 - Breaking Nested Loops...")
    val nums1 = List(1,2,3,4,5)
    val nums2 = List(11,12,13)

    val outer = new Breaks
    val inner = new Breaks

    outer.breakable {
        for(a <- nums1) {
            println(s"$a")

            inner.breakable {
                for(b <- nums2) {
                    println(s"\t$b")

                    if( b % 2 == 0) {
                        inner.break
                    }
                }	// for(b).
            }	// inner breakable.
        }	// for(a).
    }	// outer breakable.
  }
  
do-while Loop:
do <expression> while(<condition>)
do {
	<expression>
	// remember to increment / decrement
} while(<condition>)


Traits:
-------
A trait is like an interface with partial implementation.
In other languages (Java, C#, C++), interfaces cannot have any implementation. If partial implementation is required, you have define it as an abstract class.
It's like a mix of interface and abstract class.
You can create a trait that has all abstract methods or some abstract methods and some non-abstract methods.
Traits in Scala are partially implemented interfaces.

1. Define a Trait:
scala> trait Greeting {
     |     def welcome(): Unit		// abstract method.
     | }
	 
2. Create a class that implements this Trait. The class must implement the abstract method "welcome":
scala> class Introduce extends Greeting {
     |     def welcome() : Unit = {
     |       println("Hello and welcome to Scala Traits...")
     |     }
     | }
	 
3. Create an instance of the class:
scala> var intro = new Introduce()

4. Call the welcome() method on the instance:
scala> intro.welcome()

This will not work:
scala> class Introduce extends Greeting {
     |     def welcome() : Unit
     | }
	 
You have to provide an implementation for all abstract methods of a Trait when creating a class that extends (implements) the Trait.

This is a combo of abstract and non-abstract methods:
trait Greeting {
	def welcome(): Unit
	def show(): Unit
	def add(x: Int, y: Int): Unit = {
		val z = x + y
		println(s"$x + $y = $z")
	}
}

This will not work as 2 abstract methods are not implemented:
class Introduce extends Greeting {

}

This will work:
class Introduce extends Greeting {
	def welcome(): Unit = {
		println("Hello and welcome to Scala Traits")
	}
	
	def show(): Unit = {
		println("This is a demo on Scala Traits")
	}
}

val intro = new Introduce
intro.welcome()
intro.show()
intro.add(10,200

Multiple inheritance using Traits:
Modern OOP languages do not support multiple inheritance of classes.
This is not allowed:
class ClassA

class ClassB

class C extends ClassA, ClassB

To overcome this limiation, OOP languages like Java, C#, C++ etc. have "interfaces".
And Scala has "traits".

trait TraitA {
	def showA(): Unit
}


trait TraitB {
	def showB(): Unit
}

class MyClass extends TraitA with TraitB {
	def showA(): Unit = {
		println("This is the showA() method...")
	}

	def showB(): Unit = {
		println("This is the showB() method...")
	}
}

val classObj = new MyClass
classObj.showA()
classObj.showB()

Packages:
---------
project's root folder
	src
		main
			scala
				example
					a.scala
					b.scala
					c.scala
				ecommerce
					admin
						customers
							Demo1.scala
							
// Either import individually:
import ecommerce.admin.customers.CustomersTrait
import ecommerce.admin.customers.AddCustomers

// OR Import everything:
import ecommerce.admin.customers._
 
// Using alias:
import ecommerce.admin.customers.{CustomersTrait => ct}
import ecommerce.admin.customers.{AddCustomers => ac}

class CustomersClass extends ct {
	:
}

val addCust = new ac

Classes and Objects (Object Oriented Programming) in Scala:
-----------------------------------------------------------
Any class that is created or is built-in, is derived from AnyRef.

scala> class User {
     |    val name: String = "John"
     |    def message: String = s"Hello $name"
     | }
	 
scala> val usr = new User

scala> print(usr.message)

scala> class User {
     |    val name: String = "John"
     |    def message: String = s"Hello $name"
     |    override def toString = s"User is $name"
     | }
	 
scala> val usr = new User

scala> print(usr.toString())

Using ctor:
class User(val name: String) {
	def message: String = s"Hello $name"
	override def toString = s"User is $name"
}

scala> println(usr.message)

scala> println(usr.name)

scala> val userList = List( new User("John"), new User("Mary"), new User("Joe") )
scala> val sortedList = userList.sortBy(_.name)
scala> sortedList(0).name
val res29: String = Joe

scala> sortedList(1).name
val res30: String = John

scala> sortedList(2).name
val res31: String = Mary

Inheritance:
class A {
	def message = "Hello"
}

class B extends A {
}

val objB = new B()
println(objB.message)

class C extends B {
	override def message = "Welcome!"
	
	val foo = "This is foo"
	def show: Unit = {
		println("This is C.show()...")
	}
}
val objC = new C()
println(objC.message)

Access Modifiers:
private
protected
public

By default, all class members (variables/methods) are "public", meaning accessible outside of the class.

private:
private members of classes are visible only inside the class / object that contains the definition.

class Outer {
	class Inner {
		private def foo() {
			println("This is Inner.foo()...")
		}
		
		class InnerMost {
			foo()			// Will work!
		}
	}
	
	//(new Inner).foo()		// Will not work.
}

protected:
Protected members of a class are only accessible from subclasses of the class in which the member is defined and the class itself where it has been defined.

class Super {
	protected def foo() {
		println("This is Super.foo()...")
	}
	
    def printFoo() {
        foo()
    }	
}

class SubClassA extends Super {
	foo()
}


class Outsider {
	(new Super).foo()
}

With class definitions, 
	you can specify params for the ctor.
	when creating objects, you can use named params.
	you can also have default values for the params.
	
Example:
package example

class Car(val make: String, val year: Int, var reserved: Boolean = false) {
    def reserve(status: Boolean): Unit = {
        reserved = status
    }
}

object CarDemo {
  def main(args: Array[String]) {
      val car1 = new Car("Honda", 2019)
      val car2 = new Car("Audi", 2020)
      val car3 = new Car("BMW", 2021)
      
      println(s"${car1.make} from the year ${car1.year}")
      println(s"${car2.make} from the year ${car2.year}")
      println(s"${car3.make} from the year ${car3.year}")

      val car4 = new Car(year=2020, make="Toyota")      // using named params (keyword identifiers))
      println(s"${car4.make} from the year ${car4.year}")

      val car5 = new Car(year=2020, make="Toyota", reserved = false)      // using named params (keyword identifiers))
      println(s"${car5.make} from the year ${car5.year} is reserved? ${car5.reserved}")
      car5.reserve(true)
      println(s"${car5.make} from the year ${car5.year} is reserved? ${car5.reserved}")

  }
}

Abstract Classes:
An Abstract Class cannot be instantiated.
It can only be extended by other classes.

abstract class Car {
	val year: Int
	var make: String
	def color: String
}

val car1 = new Car()		// Error!

class RedBMW(val year: Int) extends Car {
	def color = "Red"
	var make = "BMW"
}

Anonymous Class:
A nameless and non-reusable class.

abstract class Listener {
	def trigger
}

val myListener = new Listener {
	def trigger {
		println("This is the trigger() method in myListener as an Anon class...")
	}
}

Case Classes:
Are like any other regular class, good for creating (modeling) immutable data.
They are immutable by default.
Define using the keyword "case".

case class ClassName(params)

case class Book(name: String)

val hp1 = Book("The Philosopher's Stone")

case class Message(sender: String, receiver: String, body: String)

val msg1 = Message("Ajay Singala", "John smith", "This is a sample message.")

println(msg1.body)
msg1.sender = "Mary Jane"			// Error! Immutable!!!

val msg2 = Message("ajay@abc.com", "Jsmith@xyz.com", "This is another sample message.")

Comparison:
val msg3 = Message("ajay@abc.com", "Jsmith@xyz.com", "This is another sample message.")

msg1 == msg2	// false
msg2 == msg3	// true

Copying:
val msg4 = msg3.copy(sender=msg3.receiver, receiver="joe@yus.com")
val msg5 = msg3.copy()
msg5.sender = "new@email.com"	// Error! Immutable.

Overloaded Methods:
Within the class, 2 (or more) functions with the same name but different parameters. Signature of ,methods must be different.
Return type is NOT part of the signature.
Different params means (method signature):
	no. of params
	type of the params
	order of the params
	
class Math {
	def add(a: Int, b: Int) : Int = { a + b }
	def add(x: Int, y: Int, z: Int) : Int = { x + y + z}
	def add(x: Float, y: Float): Float = {x + y}

	def add(x: int, y: Float): Float = {x + y}
	def add(x: Float, y: int): Float = {x + y}
	
	def add(x: int, y: int): Float = {x + y}		// Error as return type is not part of the method signature.

}

val m = new Math()
println(m.add(5,5))
println(m.add(8,25,156))
println(m.add(105.25f, 245.90f))


class Car {
	def start() {
	
	}
	
	def start(mode: String) {
	
	}
}


val c1 = new Car()
c1.start()
c1.start("mobile")


Final classes:
You cannot extend a "final" class. Defined using the "final" modifier.

scala> final class Employee {
     |    var name = "John"
     | }

scala> class Manager extends Employee
                             ^
       error: illegal inheritance from final class Employee
	   
Sealed classes:
Used to restrict the extension of classes. It allows to extend, but the subclass must be defined in the same source file.
Defined using the "sealed" keyword / modifier.

sealed class ClassName

Tuples:
-------
Ordered container / collection of two or more values.
All values may be of different types.
Created using comma separated values within parantheses.
Tuples are immutable.

val data = (25, "John Smith", "Dallas", "TX")

Values in tuples can be accessed using their 1-based index.
data._1		// 25
data._2		// John Smith.

scala> data.productIterator.foreach(println)
25
John Smith
Dallas
TX

Create tuple using the -> operator, a.k.a. the relation operator.
val red = "red" -> "0xff0000"

scala> val reversed_red = red._2 -> red._1

scala> val t = new Tuple3(1,2,3)
val t: (Int, Int, Int) = (1,2,3)

scala> val nums = (4,3,2,1)
val nums: (Int, Int, Int, Int) = (4,3,2,1)

scala> val sum = nums._1 + nums._2 + nums._3 + nums._4
val sum: Int = 10

Iterate over a Tuple:
using foreach{}
val nums = (4,3,2,1)

nums.productIterator.foreach { i => println(s"Value is $i") }

Convert to string:
val t = ("Hello", "There")
println(t.toString())

val t = (12, "Hello", "There")
println(t.toString())

Swapping:
val t = ("Hello", "There")
println(t.swap)

To return multiple values from a function, use Tuple:
package example

object TupleDemo {
    def main(args: Array[String]) {
        val result = foo()
        result.productIterator.foreach(println)
    }

    def foo() = {
        val data = (25, "John Smith", "Dallas", "TX")

        data
    }
}

Comments:
---------
3 types:
//			Single line comments.
/* */		Multi-line comments.
/** */		Documentation comments.

Functions:
----------
Are reusable, named expressions.
They may be parameterized. Not mandatory to have params.
They may return a value. Not mandatory to return value.
We create and use functions to reduce duplicate code.
Try to keep functions as small as possible. Modularize!

def calculateSalary(empId: Int): Float {
	// determine leaves taken.
	val leaves = getLeaves(empId)
	// do basic calc of salary.
	val basicSalary = calcBasicSalary(empId, 3, 2022)
	// determine tax applicable.
	val taxPayable = calcTax(empId, basicSalary)
	// any other calc.
	val others = otherCalcs(empId, 3, 2022)
	
	// calc final salary.
	val salary = // some calc.
	salary
}

def getLeaves(empId: Int): Int {

}

def calcBasicSalary(empId: Int, month: Int, year: Int): Float {

}

def calcTax(empId: Int, basicSalary: Float): Float {

}

def otherCalcs(empId: Int, month: Int, year: Int): Float {

}

Pure Functions:
- Has one or more input params.
- Returns a value.
- Performs calculations using only the input params.
- Always returns the same value for the same input.
- Deos not use or affect any data outside of the function.
- Is not affected by any data outside of the function.

scala> def formatData(amount: Double): String = {
     |  f"USD $amount%.2f"
     | }
def formatData(amount: Double): String

scala> println(formatData(1234.5789))
USD 1234.58

Print the $ sign:
scala> def formatData(amount: Double): String = {
     |  f"$$ $amount%.2f"
     | }
def formatData(amount: Double): String

scala> println(formatData(1234.5789))
$ 1234.58

Another way to create a function as a single expression:
def formatData(amount: Double) = f"$$ $amount%.2f"

Call functions with expression blocks:
scala> formatData { val rate = 1.12; 0.235 + 0.1723 + rate * 5.32 }
val res93: String = $ 6.37

The above is similar to this:
def calcAmount(): Double = { 
	val rate = 1.12
	0.235 + 0.1723 + rate * 5.32 
}

formatData(calcAmount())

Function with variable parameters (variable no. of arguments):
printStrings("Hello")
printStrings("Hello", "there")
printStrings("Hello", "there", "Welcome")

One solution Function Overloading.
printStrings("Hello", "there", "Welcome", "How", "are", "you", "doing")

def printStrings(args: String*) = {
	var i = 1
	for(arg <- args) {
		println(s"Argument #$i is $arg")
		i += 1
	}
}

Nested Functions:
def max(x: Int, y: Int, z: Int) = {
	def max2(a:Int, b: Int) = {
		if(a > b) a else b
	}
	
	max2(x, max2(y,z))
}

Named parameters:
def greet(name: String, title: String) {
	println(s"Hello $title. $name. Welcome!")
}

Params with default values:
def greet(name: String, title: String = "Mr.") {
	println(s"Hello $title $name. Welcome!")
}

Higher-Order functions:
- Takes a function as a param
- Returns a function
- or both

Anonymous functions (lambda), a.k.a Function Literals:
val doubler = (x: Int) => x * 2

scala> val multiply = (x:Int, y: Int) => x * y
val multiply: (Int, Int) => Int = $Lambda$1462/0x00000001008eb840@a50d0f9

scala> print(multiply(2,5))
10
scala> val multiply = (x:Int, y: Int) => {val z = x * y; z }
val multiply: (Int, Int) => Int = $Lambda$1463/0x00000001008eb040@38a392bd

scala> print(multiply(2,5))
10

Exception Handling:
-------------------
package example

import java.io.IOException

object ExceptionDemo {
    def main(args: Array[String]) {

        println(divide(10,2))
        println(divide(10,0))
    }

    def divide(x: Int, y: Int): Any = {
        try {
            println(s"Dividing $x by $y...")
            var result = x / y

            //throw new Exception("This is a manual excecption for testing...")
            result
        }
        catch {
            case ex: ArithmeticException => {
                println(s"ERROR! Divide operation failed!!! ($ex)")
            }
            case fex: IOException => {
                println(s"ERROR! File operation failed!!! ($fex)")
            }
            case a: Throwable => println(s"Some exception happened!!! ($a)")
        }
        finally {
            println("This block will always execute.")
        }
    }
}

Scala Collections:
------------------
2 types:
- mutable
	- scala.collection.mutable
- immutable
	- scala.collection.immmutable

Traversable trait methods:
head:		returns the first element of collection.
tail:		returns all elements except the first one.
init:		returns all elements except the last one.
last:		returns the last element.
isEmpty:	checks if coll is empty or not. Returns true or false.
max:		returns the largest element in the coll.
min:		returns the smallest element in the coll.
size:		returns the size of the coll (no. of elements).
sum:		returns the sum of all elements.
toArray:	converts coll into an Array.
toList:		converts coll into a List.
toSet:		converts coll into a Set.
toSeq:		converts coll into a Sequence.

Scala Set Collection:
Is an immutable, unordered collection of unique elements.
Used to store unique values.

val uniqueNums = Set(10, 20, 30, 20, 40, 50, 20)
val set1 = Set()	// An empty set.

Merge 2 Sets using the ++ operator:
val games = Set("Baseball", "Hockey", "Football", "Tennis")
val alphabets = Set("A", "B", "C", "D", "E")
val mergedSet = games ++ alphabets
scala> println(games.size)
4

scala> println(alphabets.size)
5

scala> println(mergedSet.size)
9

Check if a value exists in a Set:
println(games.contains("Tennis"))

Add/Remove elements from a Set:
scala> var games = Set("Baseball", "Hockey", "Football", "Tennis")
var games: scala.collection.immutable.Set[String] = Set(Baseball, Hockey, Football, Tennis)
scala> games += "Formula 1"

scala> println(games)

scala> games += "Golf"

scala> games -= "Hockey"
scala> games -= "Swimming"		// No error if does not exist.

Iterate a Set:
for(game <- games) {
	println(game)
}

games.foreach( (elem: String) => println(elem) )

Set Operations on Scala Set collection:
-intersect: common elements between sets.
-union: values from the sets ignoring duplicates between them.
-&	:	alternative to intersect.

var games = Set("Baseball", "Hockey", "Football", "Tennis", "C")
val alphabets = Set("A", "B", "C", "D", "E", "Football")

val intersectSet = games.intersect(alphabets)
val unionSet = games.union(alphabets)
val intersect2 = games & alphabets			// Intersect.

import scala.collection.immutable.SortedSet

val numbers = SortedSet(5,8,1,12,9,20,4)
//val numbers: SortedSet[Int] = SortedSet(5,8,1,12,9,20,4)
numbers.foreach( (num: Int) => println(num) )

Scala Seq Collection:
Seq is a trait.
It represents indexed sequences that are immutable and ordered.
You can access elements using their 0-based indexes.
Can have duplicates.

import scala.collection.immutable._

val nums = Seq(5,8,1,12,9,20,4)
nums.foreach( (num: Int) => println(num) )
println(nums(0))
println(nums(1))
println(nums(4))

println(nums.contains(12))

Seq methods:
indexOf()		: returns the first index of the value/element.
lastIndexOf()	: returns the last index of the value.
reverse()		: returns the elements in reverse order.
endsWith()		: check if the Seq ends with a sequence of elements.

val nums = Seq(5,8,1,12,9,20,4,20,8)

Scala List Collection:
----------------------
An immutable collection.
Are use to store ordered elements.
It extends the LinearSeq trait.
They work in a LIFO (Last In, First Out) pattern,. like a stack.
It can have duplicates.
They are like Arrays. Meaning, all elements in a List have the same type.

val numbers = List(5,8,1,12,9,20,4,20,8)
val colors = List("Red", "Green", "Blue")

println(colors.size)
println(s"There are ${colors.size} colors in the list: $colors")

scala> colors.head
val res164: String = Red

scala> colors.tail
val res165: List[String] = List(Green, Blue)

scala> colors.isEmpty
val res166: Boolean = false

println(colors(1))

Iterate a list:
var total = 0
for( i <- numbers) {
	total += i
}
println(total)

for( color <- colors) { println(color) }

colors.foreach( (col: String) => println(col) )

Using map and reduce with Lists:
map()	: takes a function that convert a single list element into another value/type.
val sizes = colors.map( (col: String) => col.size )

reduce():	takes a function that combines two list elements into a single element.
val total = numbers.reduce( (a: Int, b: Int) => a + b)

List can contain other lists:
scala> val oddsAndEvens = List( List(1,3,5), List(2,4,6) )
val oddsAndEvens: List[List[Int]] = List(List(1, 3, 5), List(2, 4, 6))

List can contain tuples:
scala> val kvPairs = List( ('A', 65), ('B', 66), ('C', 67) )
val kvPairs: List[(Char, Int)] = List((A,65), (B,66), (C,67))

Nil an instance of List[Nothing]
scala> val emptyList = List()
val emptyList: List[Nothing] = List()

scala> println(emptyList == Nil)
true

scala> val names = List("John")
val names: List[String] = List(John)

scala> names.head
val res176: String = John

scala> names.tail
val res177: List[String] = List()

scala> names.tail == Nil
val res178: Boolean = true

Append data to a list using the :+= operator:
Declare the list as a "var".
var numbers = List(5,8,1,12,9,20,4,20,8)
scala> numbers :+= 15

scala> println(numbers)
List(5, 8, 1, 12, 9, 20, 4, 20, 8, 15)

scala> var names = List("John", "Mary")
var names: List[String] = List(John, Mary)

scala> names :+= "Joe"

scala> names
val res184: List[String] = List(John, Mary, Joe)

Merge lists:
val moreNumbers = List(16, 19, 34)
val mergedList = numbers ++ moreNumbers

Sort list:
val sortedList = mergedList.sorted

Reverse list:
val reversedList = sortedList.reverse

distinct() is used to delete duplicate elements from a list:
val distinctList = sortedList.distinct

filter() is used to select elements based on a condition (prediate):
val filteredList = distinctList.filter(_ < 15)

Scala ListBuffer:
Mutable collection.
It supports append and prepend operations.
Once your ListBuffer is ready, you can convert it into a List by using the toList() method.
import scala.collection.mutable.ListBuffer

var names = new ListBuffer[String]()
var names = new ListBuffer("John", "Mary", "Joe")

Add values to ListBuffer by using the += operator.
scala> var names = new ListBuffer[String]()
var names: scala.collection.mutable.ListBuffer[String] = ListBuffer()

scala> names += "John"
val res186: scala.collection.mutable.ListBuffer[String] = ListBuffer(John)

scala> names += "Mary"
val res187: scala.collection.mutable.ListBuffer[String] = ListBuffer(John, Mary)

scala> names += "Jone"
val res188: scala.collection.mutable.ListBuffer[String] = ListBuffer(John, Mary, Jone)

scala> names
val res189: scala.collection.mutable.ListBuffer[String] = ListBuffer(John, Mary, Jone)

scala> names.append("Joe")
val res190: scala.collection.mutable.ListBuffer[String] = ListBuffer(John, Mary, Jone, Joe)

Remove elements using -=:
scala> names -= "Jone"
val res191: scala.collection.mutable.ListBuffer[String] = ListBuffer(John, Mary, Joe)

Remove elements using remove():
names.remove(0)	// Removes elem #0 from the list and also returns the elem.
names.remove(1,3)	// removes starting from element 1 and 3 elements, so it removes elems 1,2,3
names.remove(m,n)	remove starting from elem "m" and remove the next "n" elems including the mth elem.

Prepend values to a list using the +=: operator:
Syntax: new_value +=: list

scala> "John" +=: names
val res206: scala.collection.mutable.ListBuffer[String] = ListBuffer(John, Mary, Walter, Caleb)

Scala Maps:
An immutable collection of key-value pairs.
a.k.a. hasmap, dictionary
The keys have to be unique.
Values can be duplicated.
Created using the -> operator.
Syntax is Map(key -> value)

scala> val colorMap = Map( "red" -> "0xff0000", "green" -> "0xFF00", "blue" -> "0xFF")
val colorMap: scala.collection.immutable.Map[String,String] = Map(red -> 0xff0000, green -> 0xFF00, blue -> 0xFF)

scala> val nums = Map("One" -> 1, "Two" -> 2, "Three" -> 3)
val nums: scala.collection.immutable.Map[String,Int] = Map(One -> 1, Two -> 2, Three -> 3)

Retrieve values from a map using the "key":
scala> colorMap("red")
val res207: String = 0xff0000

val colorMap = Map( "red" -> 0xff0000, "green" -> 0xFF00, "blue" -> 0xFF)

scala> colorMap("green")
val res210: Int = 65280

scala> colorMap("blue")
val res211: Int = 255

scala> val cyan = colorMap("green") | colorMap("blue")
val cyan: Int = 65535

Check if value exists in Map:
scala> colorMap.contains("white")
val res212: Boolean = false

scala> colorMap.contains("red")
val res213: Boolean = true

Iterate a map:
scala> for( colorPair <- colorMap) { println(colorPair) }
(red,16711680)
(green,65280)
(blue,255)

Add / Remove elements in Map:
scala> var map = Map("A"->"Apple", "B"->"Ball")
var map: scala.collection.immutable.Map[String,String] = Map(A -> Apple, B -> Ball)

scala> map("A")
val res222: String = Apple

scala> map("B")
val res223: String = Ball

scala> var newMap = map+("C"->"Cat")
var newMap: scala.collection.immutable.Map[String,String] = Map(A -> Apple, B -> Ball, C -> Cat)

scala> map
val res224: scala.collection.immutable.Map[String,String] = Map(A -> Apple, B -> Ball)

scala> newMap
val res225: scala.collection.immutable.Map[String,String] = Map(A -> Apple, B -> Ball, C -> Cat)

List Operators and Methods:
++			merge.
== 			compare.
distinct	returns a list with distinct values.
drop		drops the first n elements from a list.
			List(11,21,32,45,58) drop 2
filer		returns elements that match a condition (predicate)
			scala> List(40, 28, 1, 15, 18, 9).filter(_ < 10)
			val res228: List[Int] = List(1, 9)

			scala> List(40, 28, 1, 15, 18, 9) filter(_ < 10)
			val res229: List[Int] = List(1, 9)
flatten		Converts a list of lists into a single list of elements.
			scala> val numbers = List( List(1,2), List(3,4), List(5,6) )
			val numbers: List[List[Int]] = List(List(1, 2), List(3, 4), List(5, 6))

			scala> println(numbers)
			List(List(1, 2), List(3, 4), List(5, 6))

			scala> val flattenedList = numbers.flatten
			val flattenedList: List[Int] = List(1, 2, 3, 4, 5, 6)

			scala> println(flattenedList)
			List(1, 2, 3, 4, 5, 6)

			scala> val names = List("John", "Mary")
			val names: List[String] = List(John, Mary)

			scala> println(names.flatten)
			List(J, o, h, n, M, a, r, y)
reverse		Reverses the list.
slice		Returns a section of the list from the first index to the last one, but not including the last one.
			scala> List(2,3,5,7,8).slice(1,3)
			val res234: List[Int] = List(3, 5)

			scala> List(2,3,5,7,8).slice(1,5)
			val res235: List[Int] = List(3, 5, 7, 8)

			scala> List(2,3,5,7,8).slice(1,4)
			val res236: List[Int] = List(3, 5, 7)
sortBy		orders the list based on the given function
			scala> List("apple", "tomato", "kiwi", "car", "reversedList").sortBy(_.size)
			val res237: List[String] = List(car, kiwi, apple, tomato, reversedList)
sorted		orders a list by it's natural values.
splitAt		Groups elements into tuples of two lists based on if they fall before or after the given index number (1-based).
			scala> List(2, 3, 5, 7) splitAt 2
			val res238: (List[Int], List[Int]) = (List(2, 3),List(5, 7))

			scala> List(2, 3, 5, 7, 8) splitAt 2
			val res239: (List[Int], List[Int]) = (List(2, 3),List(5, 7, 8))

			scala> List(2, 3, 5, 7, 8, 9, 20, 100) splitAt 2
			val res240: (List[Int], List[Int]) = (List(2, 3),List(5, 7, 8, 9, 20, 100))
take 		Extracts the first n elements from the list.
			scala> List(2,6,10,29,50).take(3)
			val res241: List[Int] = List(2, 6, 10)


map() and flatMap():
--------------------
map() transforms a collection by applying a function to each element in that collection.

val languages = List("Scala", "Python", "C#", "Java", "COBOL", "Visual Basic")
scala> languages.map(lang => lang.toUpperCase)
val res243: List[String] = List(SCALA, PYTHON, C#, JAVA, COBOL, VISUAL BASIC)

scala> languages.map(_.toUpperCase)
val res244: List[String] = List(SCALA, PYTHON, C#, JAVA, COBOL, VISUAL BASIC)

scala> val sizes = languages.map(_.length)
val sizes: List[Int] = List(5, 6, 2, 4, 5, 12)

scala> println(sizes)
List(5, 6, 2, 4, 5, 12)

flatMap() is similar to map() with the difference that flatMap() flattens the elements.
It returns a Seq if the collection being worked on is a Seq.
It returns a List if the collection being worked on is a List.

scala> val names = Seq("John", "Mary")
val names: Seq[String] = List(John, Mary)

scala> println(names.flatMap(_.toLowerCase))
List(j, o, h, n, m, a, r, y)

scala> val nm = names.flatMap(_.toLowerCase)
val nm: Seq[Char] = List(j, o, h, n, m, a, r, y)

Split using flatMap():
scala> val names = List("John,Mary,Joe")
val names: List[String] = List(John,Mary,Joe)

scala> println(names.flatMap(_.split(",")))
List(John, Mary, Joe)

Filtering:
----------
scala> val nums = List(1,2,3,4,5,6,7,8,9,10)
val nums: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> val evens = nums.filter( (num: Int) => num % 2 == 0)
val evens: List[Int] = List(2, 4, 6, 8, 10)

Code:
package example

case class Person(firstName: String, lastName: String, title: String)

object FilterDemo {
    def main(args: Array[String]) {
        val people = Seq(
            Person("John", "Smith", "Mr."),
            Person("Mary", "Jane", "Ms."),
            Person("Joe", "Caleb", "Mr.")
        )

        val labels = people.map( person => s"${person.title} ${person.firstName} ${person.lastName}")
        println(labels)

        val peopleThatStateWithJ =people.filter(_.firstName.startsWith("J"))
        println(peopleThatStateWithJ)
    }
}

Using "reducers" on collections:
scala> List(41,59,89,10).max
val res252: Int = 89

scala> List(41,59,89,10).min
val res253: Int = 10

scala> List(41,59,89,10).product
val res254: Int = 2152910

scala> List(41,59,89,10).sum
val res255: Int = 199

Boolean Reduction Operations:
contains:
scala> List(2,6,10,29,50).contains(29)
val res256: Boolean = true

scala> List(2,6,10,29,50).contains(26)
val res257: Boolean = false

endsWith:
scala> List(2,6,10,29,50).endsWith(List(29,50))
val res258: Boolean = true

scala> List(2,6,10,29,50).endsWith(List(29,51))
val res259: Boolean = false

startsWith:
scala> List(2,6,10,29,50).startsWith(List(0))
val res264: Boolean = false

scala> List(2,6,10,29,50).startsWith(List(2))
val res265: Boolean = true

scala> List(2,6,10,29,50).startsWith(List(2,6))
val res266: Boolean = true

exists:
scala> List(2,6,10,29,50).exists(_ < 25)
val res261: Boolean = true

scala> List(2,6,10,29,50).exists(_ > 125)
val res262: Boolean = false

Pattern Matching with Collections:
----------------------------------
scala> val statuses = List(500, 404)
val statuses: List[Int] = List(500, 404)

scala> val msg = statuses.head match {
     | case s if s < 500 => "OKAY!"
     | case _ => "Some error occured..."
     | }
val msg: String = Some error occured...

scala> val msg = statuses match {
     | case s if s contains(500) => "ERROR!!!!"
     | case _ => "All A-OK!"
     | }
val msg: String = ERROR!!!!

val msg = statuses match {
	case List(404,500) => "not found & server error"
	case List(500,404) => "server error & not found"
	case List(200,200) => "All Okay!"
	case _ => "Not sure what happened."
}

File I/O:
---------

Inheritance in Scala:
Super (base) Class
Sub Class

class subclass extends superclass {
	// methods and fields.
	
}

Types of inheritance:
Single inheritance:
class Person {
}

class Employee extends Person {
}

Multi-level inheritance
class Vehicle {
}

class Car extends Vehicle {
}

class BMW extends Car {
}


Hierarchical inheritance:
class Vehicle {
}

class Car extends Vehicle {
}

class Vehicle {
}

class Truck extends Vehicle {
}

class MotorBike extends Vehicle {
}

Multiple inheritance:
trait Mobile {
}

trait Laptop {
}

class Tablet extends Mobile with Laptop {
}

trait Tablet extends Mobile with Laptop {
}

Hybrid inheritance:
trait Device {
}

trait Mobile extends Device {
}

trait Laptop  extends Device {
}

class Tablet extends Mobile with Laptop {
}

