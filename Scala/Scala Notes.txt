Scala:
After Python, it is one of most popular programming languages for Big Data.
Java-based, it runs on the JVM.
Not derived from "La Scala" - Italian staircase / ladder.
It is an abbreviation for SCAlable LAnguage
Professor Martin Odersky in ~2003.
High-performance, scalable, functional programming language, Object Oriented Language.
It runs on the JVM - Java Virtual Machine.

Scala is an Object Oriented Language:
It is a pure OO language in the sense that every value in Scala is an object.
Types & object behaviors are described by classes and traits.

Achieve inheritance (classes are extended) by subclassing.

Scala is Functional:
Every function is a value, and every value is an object, so ultimately, every function is also an object.

Scala provides Anonymous Functions, it supports Higher-Order Functions., also supports nested functions.

Scala is Statically typed:
Most progamming languages require you to specify a type, but Scala does not expect you to do that.
Scala has it's own defined sets of types.

It runs on the JVM - Java Virtual Machine:
You write code in Scala.
When you compile it, it is convered into Java Byte Code, which is then executed by the JVM.
Compiling is done using the command "scalac" and execution is done using "scala".

Create a source code file: first.scala
scalac will compile it and create first.class
scala will execute the byte code first.class

Scala can execute Java code as well.

Scala vs Java:
- All types are objects.
- Type inference.
- Nested functions.
- Functions are objects.
- Traits.

Functional Programming:
-----------------------
Uses functions as a building block of programs.
We strive to use "pure" functions and immutable values.

Immutability:
State (value) of variables (objects) cannot be changed. We can create a new object, but we cannot modify the existing object's state.

Pure Functions:
A pure function has tow key properties:
1) It always returns the same value for the same input.
2) It has no side effects. A function does not interact with anything (variable/object) outside of the function. This could be global variables, mutable objects, I/O operations etc.

Functions are treated as "First Class Citizens":
------------------------------------------------
Scala treats all functions as First Class functions/citizens by default.
Functions are values:
- a function can be assigned to a variable.
- it can be passed as an argument to other function.
- it can be returned as a value from other functions.

function add(a, b) {
	some code
	:
}


objectAdd = add
objectAdd(10,20)

function math(fn, x, y) {
	fn(x,y)
}

math(objectadd, 10,20)

function foo() {
	fnAdd = add
	:
	:
	:
	return fnAdd

}

Higher-Order Functions (HOF):
-----------------------------
A HOF is a function that has at least one of the following properties:
1. Takes one or more functions as parameters.
2. Returns a function as a result.

def calcAnything(number: Int, calcFunction: Int => Int): Int = calcFunction(number)

def calcSquare(num: Int): Int = num * num

def calcCube(num: Int): Int = num * num * num

val squareResult = calcAnything(2, calcSquare)			// returns 4.
val cubeResult = calcAnything(3, calcCube)				// returns 27.

Concpets of Functional Programming:
- Pure functions
- Variables are immutable
- Functions are First-class and can be Higher-order
- Recursion


Installing Scala:
JDK 8
SBT = Scala Build Tool
	Alternative to scalac and scala
Scala

JDK: https://www.oracle.com/java/technologies/downloads/#java8-windows (select x64 installer)
Scala: https://www.scala-lang.org/download/2.13.6.html
SBT: https://github.com/sbt/sbt/releases/download/v1.5.5/sbt-1.5.5.msi

Ensure the following Environment variables are created and properly initialized:
JAVA_HOME: path to the JDK folder. For e.g.; C:\Program Files\Java\jdk-11.0.12
In the PATH variable, add these:
	Path to the JDK's bin folder. For e.g.; C:\Program Files\Java\jdk-11.0.12\bin
	Path to the SBT bin folder. For e.g.; C:\Program Files (x86)\sbt\bin
	Path to the Scala bin folder. For e.g.; C:\Program Files (x86)\scala\bin
	
Scala execution modes:
- Interactive Mode (REPL)
	- Command/Terminal window
- Script Mode
	- IDE (VS Code)
	- Using scalac, scala
	- sbt
	
Scala is case-sensitive!

sbt project structure:
	project folder
		project
		target
		src
			main
				scala
				

Create a new folder
run sbt
From another command window or File Explorer:
	create folder structure in the new folder mentioned above:
			project
			target
			src
				main
					scala
						<package folder> For e.g.; examples

Using an editor, create a .scala file in src\main\scala\examples

From the sbt prompt, execute the command "compile".
Then, from the sbt prompt, execute the command "run".

Command to create a sbt project for Scala with folders and build.sbt file:
sbt new scala/scala-seed.g8 (preferred)
OR 
sbt new sbt/scala-seed.g8


The folder where the build.sbt file is located is the "root" folder of your project.
This root folder will also have the "src" folder.
 
In VSC, install the following extensions:
- Scala (Metals) by Scalameta
- Scala (sbt) by Lightbend
- Scala Syntax (official) by Scala-Lang
	
To declare a variable, use either val or var. For e.g.:
val x = 10
val name = "Ajay Singala"

Scala REPL, Variables and Values:
---------------------------------
REPL: Read Evaluate Print Loop
Scala is not really an interpreted language. It is a compiled language.
A literal:  data that appears as-is directly in the code. For e.g.; the number 7, the character A, or the string "Hello".
A value: is an immutable, typed storage unit. A value can be assigned data when it is defined, but cannot be reassigned.
val x = 10
x = 20			// Not possible.
A variable: is a mutable, typed storage unit. A variable can be assigned data  when it is defined, and can also be reassigned data at any time.
var x = 10
x = 20			// Will work.

Scala Data Types:
-----------------
Basic Data Types: (Value Types)
Boolean:	true or false
Int
Char
Float
Double
Byte
Short
Long

(Reference Types)
String
List
Array
Class

Advanced Data Types:
Unit:	Means to no value.
Null:	Null or empty reference.
Nothing:Subtype of every other type, includes no values.
Any:	Supertype of all other type; any object is of type Any.
AnyRef: Supertype of any reference type.

Passing by value:
def foo(x: Int) {
	x = x * 2
	println(x)	// 20
}

var i = 10
println(i)		// 10
foo(i)
prinln(i)		// 10

Basic Syntax and Terms in Scala:
--------------------------------
Object - Objects have states and behaviors. An object is a runtime instance of a Class. For e.g.; a Dog has states: color, name, breed. has behavior: wagging, barking, eating, running.
Class: A template / blueprint, which describes the behaviors/states of the class.
Fields: Each object has its own unique sets of instance variables, known as fields.
	dogA - Max, black, German Shepherd.
	dogB - Tommy, brown, Terrier.
Traits: 
	Most modern programming languages do not allow multiple inheritance.
	But there can be situations where you want to inherit from multple classes.
	In such scenarios, we use Traits (in other languages, equivalent are abstract classes and interfaces). 
	Traits are very similar to classes.
	A trait encapsulates (has) methods and field definitions, just like a class.
	But, in a trait, you can define a method without it's implementation (just provide the signature).
		- such methods are known as abstract methods.

Scala Coding Conventions:
-------------------------
Case sensitivity - scala is case sensitive.
Class names: Capitalized words For e.g.; class MyFirstClass
Method names: start with a lower case For e.g.; def getCustomerName()
Program Filename: the filename must be same as the object created in the program. For e.g.; if the code is this:
object MyFirst {
	def main(args: Array[String]) {
		:
		:
	}	
}

Then the filename should be MyFirst.scala

Starting point: the main method as follows:
	def main(args: Array[String]) {

	}

Scala Identifiers:
------------------
Names used for objects, classes, functions, variables are called Identifiers.
Legal alphanumeric identifiers: Should start with either an alphabet or an underscore ( _ )
	- For e.g.; age, salary, _firstName, _first_name, last_name, __order_number 
Illegal identifiers: Cannot start with $, -, number
	- For e.g.; $salary, 123age, -firstname
	
Scala Keywords:
---------------
def	do	while	if	else	class	extends		false	true	import	this	throw	val	var	yield	lazy	abstract	case
match	return	with finally	trait	object	override	protected	sealed	new	Try	catch	for 
: 	=	=> @ <-

Variable Declaration:
Either use val or var.
val a = 10
var name = "Ajay"

Variable Data Types (semi-colon is optional):
val x: Int = 10;
var name: String = "John";

Multiple assignments:
val (num1: Int, name: String) = (40, "John")

You cannot declare a variable without an initial value. The following will give an error:
val a: Int;
val name: String;

To define character vaiables, use single quotes and provide a single character only! For e.g.:
val aChar = 'A'

Using multiple expressions with the help of curly braces {}:
val x  = { val a = 100; val b = 200; a + b }
println(x)

OR on multiple lines:
scala> val x = {
     | val a = 100
     | val b = 200
     | a + b
     | }

Comments:
Using double forward slash: //

Lazy Loading:
Lazy initialization means the value is not assigned "now" (during declaration).
It will be assigned when the variable is first accessed.

If you are going to store millions of values into a variable, you may not want to do this when a program starts (or a function starts).
You just lazy load the data and the actualy loading / assignment of the data will happen ONLY when the variable is accessed for the first time after the declaration.

Converting Data Type:
val strNum = "10"
val i: Int = strNum			// Error.
val i: Int = strNum.toInt	// Works!

Strings:
--------
val msg = "This is line one. \nThis is line two."
val greeting = "Hello " + "World"		// Concat.
val greeting: String = Hello World

scala> val isMatching = (greeting == "Hello World")
val isMatching: Boolean = true

scala> val isMatching = (greeting == "Hello, World")
val isMatching: Boolean = false

scala> val ttt = "Na" * 16 + "Something"
val ttt: String = NaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaSomething

scala> val ttt = "Na" + 16 + "Something"
val ttt: String = Na16Something

Multiline strings using """text goes here""" (triple quotes):
val msg = """For formatting text and adding a new line, 
specify a \n. And for tabs, specify \t.
This way, you can format your text properly.
""" 

Triple quotes do not encode/decode escape sequences. The above will print \n and \t and not a newline and tab.

String interpolation:
scala> val a = 10
val a: Int = 10

scala> val b= 5
val b: Int = 5

scala> val c = a / b
val c: Int = 2

Concat:
scala> println("a = " + a + ". b = " + b + ". c = " + c)
a = 10. b = 5. c = 2

Use interpolation instead:
scala> println(s"a = $a. b = $b. c = $c")
a = 10. b = 5. c = 2

scala> val item = "pencil"
val item: String = pencil

scala> println(s"There are 4 $item")
There are 4 pencil

scala> println(s"There are 4 ${item * 3}")
There are 4 pencilpencilpencil

if-else expression block:
-------------------------
if usage:
---------
if(cond) <expression>

if(a == b) {
	// do something
	// more code
}


val soemVariable = (a == b)

if-else usage:
--------------

if(cond) {
	// code
}
else {
	// code
}

if( x > y) x else y
Or
if(x > y) {
	x
}
else {
	y
}

if-else-if usage:
-----------------
if(cond1) {
	// expression
}
else if(cond2) {
	// expr
}
else if(cond3) {
	// expr
}
else {
	// expr
}

Match Expressions:
------------------
An efficient alternative to if-else-if statements.
Similar to switch-case statement in C#, Java etc.
        status match {
            case "New" => {
                println("A new document...")
            }
            case "In Progress" => println("The document is being reviewed...")
            case "Approved" => println("The document is Approved...")
            case "Rejected" => println("The document is Rejected...")
            case _ => println("Status unknown!!!")		// Using wildcard.
        }

Example:		
scala> val x = 10
val x: Int = 10

scala> val y = 20
val y: Int = 20

scala> val max = x > y match {
     | case true => x
     | case false => y
     | }
val max: Int = 20


Example:		
	chkDOW("MON")
	chkDOW("FRI")
	chkDOW("SAT")
	
    def chkDOW(day: String) {
        println(s"\nChecking Day of the week $day...")
        day match {
            case "MON" | "TUE" | "WED" | "THU" |"FRI" => println("Weekday!")
            case "SAT" | "SUN" => println("Weekend!!!")
        }
    }
	
Mathcing with Pattern Guards:
scala> val result : String = null
val result: String = null

scala> result match {
     | case s if s != null => println(s"The value is $s")
     | case s => println("ERROR! Value is null!!!")
     | }
ERROR! Value is null!!!

Here, "s" will have the value of "result" and in the 1st case, it checks if it is != null.

Loops:
------
The "for" loop:
for( <identifier> <- <iterator>) <expression>
for( <identifier> <- <iterator>) { <expression> ... }

For e.g.:
for(i <- 1 to 7) {
	println(i)
}

The "yield" keyword:
for(i <- 1 to 7) yield {
	s"Day $i"
}

For every value iterated in a for lopo, yield generates a value and remembers it in an internal (hidden) buffer.
When the loop completes, it returns this hidden buffer.
this hidden buffer (collection) that is returned is of the same type that we are iterating on. If we were iterating on a List, it returns a List. If we were iterating on a Map, it will return a Map.

Using guards with "for" loop:
for(i <- 1 to 10 if i > 5) yield {
	i
}

for(i <- 1 to 10 if i % 2 == 0) yield {
	i
}

Use "until" instead of "to" in for loop:
for(i <- 1 until 10) print(i)

"until" means upto the number/value on the right side, but not including that number/value.

Use "by" to specify an increment:
for(i <- 1 to 10 by 2) print(i)
This will print nos. 1,3,5,7,9 skipping every alternate value.

for( <identifier> <- m to n [guard])[yield] <expression>
for( <identifier> <- m until n [guard]) [yield] <expression>
for( <identifier> <- m to n [by <increment>])[yield] <expression>
for( <identifier> <- m until n [by <increment>])[yield] <expression>

Nested iterators:
for { x <- 1 to 2
 y <- 1 to 3 }
 { print(s"($x,$y)  ") }

Similar to:
for(x < 1 to 2) {
	for(y <- 1 to 3) {
		print(s"($x,$y) ")
	}
}

while loop:
while(<condition>) <expression>
while(<condition>) {
	<expression>
	// remember to increment / decrement
}

var x = 1
while(x <= 10) {
	print(s"$x:")
	// x = x + 1
	x += 1
}

var x = 10
while(x > 0) {
	print(s"$x:")
	x -= 1
}

var x = 1
while(x <= 10) {
	print(s"$x:")
	x += 1
	if(x > 5) {
		break
	}
}

Breaking out of a loop in Scala:
1) You have to create "named loops".
import scala.util.control._

object BreakDemo {
  def main(args: Array[String]) {
    var a = 0
    val nums = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    var myLoop = new Breaks

    myLoop.breakable {
      for (a <- nums) {
        print(s"$a: ")

        if (a > 5) {
          myLoop.break
        }
      }
    }
  }
}

2) without named loops:
  def demo2() {
    println("\nDemo 2...")
    // This requires: import scala.util.control.Breaks._
    breakable {
      for (i <- 1 to 10) {
        if (i == 6) {
          break
        }
        print(s"$i: ")
      }
    }
  }

I either case, you have to define a "breakable" expression block.

Breaking Nested Loops:
def demo3() {
    println("\nDemo 3 - Breaking Nested Loops...")
    val nums1 = List(1,2,3,4,5)
    val nums2 = List(11,12,13)

    val outer = new Breaks
    val inner = new Breaks

    outer.breakable {
        for(a <- nums1) {
            println(s"$a")

            inner.breakable {
                for(b <- nums2) {
                    println(s"\t$b")

                    if( b % 2 == 0) {
                        inner.break
                    }
                }	// for(b).
            }	// inner breakable.
        }	// for(a).
    }	// outer breakable.
  }
  
do-while Loop:
do <expression> while(<condition>)
do {
	<expression>
	// remember to increment / decrement
} while(<condition>)


Traits:
-------
A trait is like an interface with partial implementation.
In other languages (Java, C#, C++), interfaces cannot have any implementation. If partial implementation is required, you have define it as an abstract class.
It's like a mix of interface and abstract class.
You can create a trait that has all abstract methods or some abstract methods and some non-abstract methods.
Traits in Scala are partially implemented interfaces.

1. Define a Trait:
scala> trait Greeting {
     |     def welcome(): Unit		// abstract method.
     | }
	 
2. Create a class that implements this Trait. The class must implement the abstract method "welcome":
scala> class Introduce extends Greeting {
     |     def welcome() : Unit = {
     |       println("Hello and welcome to Scala Traits...")
     |     }
     | }
	 
3. Create an instance of the class:
scala> var intro = new Introduce()

4. Call the welcome() method on the instance:
scala> intro.welcome()

This will not work:
scala> class Introduce extends Greeting {
     |     def welcome() : Unit
     | }
	 
You have to provide an implementation for all abstract methods of a Trait when creating a class that extends (implements) the Trait.

This is a combo of abstract and non-abstract methods:
trait Greeting {
	def welcome(): Unit
	def show(): Unit
	def add(x: Int, y: Int): Unit = {
		val z = x + y
		println(s"$x + $y = $z")
	}
}

This will not work as 2 abstract methods are not implemented:
class Introduce extends Greeting {

}

This will work:
class Introduce extends Greeting {
	def welcome(): Unit = {
		println("Hello and welcome to Scala Traits")
	}
	
	def show(): Unit = {
		println("This is a demo on Scala Traits")
	}
}

val intro = new Introduce
intro.welcome()
intro.show()
intro.add(10,200

Multiple inheritance using Traits:
Modern OOP languages do not support multiple inheritance of classes.
This is not allowed:
class ClassA

class ClassB

class C extends ClassA, ClassB

To overcome this limiation, OOP languages like Java, C#, C++ etc. have "interfaces".
And Scala has "traits".

trait TraitA {
	def showA(): Unit
}


trait TraitB {
	def showB(): Unit
}

class MyClass extends TraitA with TraitB {
	def showA(): Unit = {
		println("This is the showA() method...")
	}

	def showB(): Unit = {
		println("This is the showB() method...")
	}
}

val classObj = new MyClass
classObj.showA()
classObj.showB()

Packages:
---------
project's root folder
	src
		main
			scala
				example
					a.scala
					b.scala
					c.scala
				ecommerce
					admin
						customers
							Demo1.scala
							
// Either import individually:
import ecommerce.admin.customers.CustomersTrait
import ecommerce.admin.customers.AddCustomers

// OR Import everything:
import ecommerce.admin.customers._
 
// Using alias:
import ecommerce.admin.customers.{CustomersTrait => ct}
import ecommerce.admin.customers.{AddCustomers => ac}

class CustomersClass extends ct {
	:
}

val addCust = new ac

Classes and Objects (Object Oriented Programming) in Scala:
-----------------------------------------------------------
Any class that is created or is built-in, is derived from AnyRef.

scala> class User {
     |    val name: String = "John"
     |    def message: String = s"Hello $name"
     | }
	 
scala> val usr = new User

scala> print(usr.message)

scala> class User {
     |    val name: String = "John"
     |    def message: String = s"Hello $name"
     |    override def toString = s"User is $name"
     | }
	 
scala> val usr = new User

scala> print(usr.toString())

Using ctor:
class User(val name: String) {
	def message: String = s"Hello $name"
	override def toString = s"User is $name"
}

scala> println(usr.message)

scala> println(usr.name)

scala> val userList = List( new User("John"), new User("Mary"), new User("Joe") )
scala> val sortedList = userList.sortBy(_.name)
scala> sortedList(0).name
val res29: String = Joe

scala> sortedList(1).name
val res30: String = John

scala> sortedList(2).name
val res31: String = Mary

Inheritance:
class A {
	def message = "Hello"
}

class B extends A {
}

val objB = new B()
println(objB.message)

class C extends B {
	override def message = "Welcome!"
	
	val foo = "This is foo"
	def show: Unit = {
		println("This is C.show()...")
	}
}
val objC = new C()
println(objC.message)

Access Modifiers:
private
protected
public

By default, all class members (variables/methods) are "public", meaning accessible outside of the class.

private:
private members of classes are visible only inside the class / object that contains the definition.

class Outer {
	class Inner {
		private def foo() {
			println("This is Inner.foo()...")
		}
		
		class InnerMost {
			foo()			// Will work!
		}
	}
	
	//(new Inner).foo()		// Will not work.
}

protected:
Protected members of a class are only accessible from subclasses of the class in which the member is defined and the class itself where it has been defined.

class Super {
	protected def foo() {
		println("This is Super.foo()...")
	}
	
    def printFoo() {
        foo()
    }	
}

class SubClassA extends Super {
	foo()
}


class Outsider {
	(new Super).foo()
}

With class definitions, 
	you can specify params for the ctor.
	when creating objects, you can use named params.
	you can also have default values for the params.
	
Example:
package example

class Car(val make: String, val year: Int, var reserved: Boolean = false) {
    def reserve(status: Boolean): Unit = {
        reserved = status
    }
}

object CarDemo {
  def main(args: Array[String]) {
      val car1 = new Car("Honda", 2019)
      val car2 = new Car("Audi", 2020)
      val car3 = new Car("BMW", 2021)
      
      println(s"${car1.make} from the year ${car1.year}")
      println(s"${car2.make} from the year ${car2.year}")
      println(s"${car3.make} from the year ${car3.year}")

      val car4 = new Car(year=2020, make="Toyota")      // using named params (keyword identifiers))
      println(s"${car4.make} from the year ${car4.year}")

      val car5 = new Car(year=2020, make="Toyota", reserved = false)      // using named params (keyword identifiers))
      println(s"${car5.make} from the year ${car5.year} is reserved? ${car5.reserved}")
      car5.reserve(true)
      println(s"${car5.make} from the year ${car5.year} is reserved? ${car5.reserved}")

  }
}

Abstract Classes:
An Abstract Class cannot be instantiated.
It can only be extended by other classes.

abstract class Car {
	val year: Int
	var make: String
	def color: String
}

val car1 = new Car()		// Error!

class RedBMW(val year: Int) extends Car {
	def color = "Red"
	var make = "BMW"
}

Anonymous Class:
A nameless and non-reusable class.

abstract class Listener {
	def trigger
}

val myListener = new Listener {
	def trigger {
		println("This is the trigger() method in myListener as an Anon class...")
	}
}

Case Classes:
Are like any other regular class, good for creating (modeling) immutable data.
They are immutable by default.
Define using the keyword "case".

case class ClassName(params)

case class Book(name: String)

val hp1 = Book("The Philosopher's Stone")

case class Message(sender: String, receiver: String, body: String)

val msg1 = Message("Ajay Singala", "John smith", "This is a sample message.")

println(msg1.body)
msg1.sender = "Mary Jane"			// Error! Immutable!!!

val msg2 = Message("ajay@abc.com", "Jsmith@xyz.com", "This is another sample message.")

Comparison:
val msg3 = Message("ajay@abc.com", "Jsmith@xyz.com", "This is another sample message.")

msg1 == msg2	// false
msg2 == msg3	// true

Copying:
val msg4 = msg3.copy(sender=msg3.receiver, receiver="joe@yus.com")
val msg5 = msg3.copy()
msg5.sender = "new@email.com"	// Error! Immutable.

Overloaded Methods:
Within the class, 2 (or more) functions with the same name but different parameters. Signature of ,methods must be different.
Return type is NOT part of the signature.
Different params means (method signature):
	no. of params
	type of the params
	order of the params
	
class Math {
	def add(a: Int, b: Int) : Int = { a + b }
	def add(x: Int, y: Int, z: Int) : Int = { x + y + z}
	def add(x: Float, y: Float): Float = {x + y}

	def add(x: int, y: Float): Float = {x + y}
	def add(x: Float, y: int): Float = {x + y}
	
	def add(x: int, y: int): Float = {x + y}		// Error as return type is not part of the method signature.

}

val m = new Math()
println(m.add(5,5))
println(m.add(8,25,156))
println(m.add(105.25f, 245.90f))


class Car {
	def start() {
	
	}
	
	def start(mode: String) {
	
	}
}


val c1 = new Car()
c1.start()
c1.start("mobile")


Final classes:
You cannot extend a "final" class. Defined using the "final" modifier.

scala> final class Employee {
     |    var name = "John"
     | }

scala> class Manager extends Employee
                             ^
       error: illegal inheritance from final class Employee
	   
Sealed classes:
Used to restrict the extension of classes. It allows to extend, but the subclass must be defined in the same source file.
Defined using the "sealed" keyword / modifier.

sealed class ClassName

Tuples:
-------
Ordered container / collection of two or more values.
All values may be of different types.
Created using comma separated values within parantheses.
Tuples are immutable.

val data = (25, "John Smith", "Dallas", "TX")

Values in tuples can be accessed using their 1-based index.
data._1		// 25
data._2		// John Smith.

scala> data.productIterator.foreach(println)
25
John Smith
Dallas
TX

Create tuple using the -> operator, a.k.a. the relation operator.
val red = "red" -> "0xff0000"

scala> val reversed_red = red._2 -> red._1

scala> val t = new Tuple3(1,2,3)
val t: (Int, Int, Int) = (1,2,3)

scala> val nums = (4,3,2,1)
val nums: (Int, Int, Int, Int) = (4,3,2,1)

scala> val sum = nums._1 + nums._2 + nums._3 + nums._4
val sum: Int = 10

Iterate over a Tuple:
using foreach{}
val nums = (4,3,2,1)

nums.productIterator.foreach { i => println(s"Value is $i") }

Convert to string:
val t = ("Hello", "There")
println(t.toString())

val t = (12, "Hello", "There")
println(t.toString())

Swapping:
val t = ("Hello", "There")
println(t.swap)

To return multiple values from a function, use Tuple:
package example

object TupleDemo {
    def main(args: Array[String]) {
        val result = foo()
        result.productIterator.foreach(println)
    }

    def foo() = {
        val data = (25, "John Smith", "Dallas", "TX")

        data
    }
}

Comments:
---------
3 types:
//			Single line comments.
/* */		Multi-line comments.
/** */		Documentation comments.
		